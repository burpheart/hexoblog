<!DOCTYPE html>
<html>
  <head>
<meta name="referrer" content="never">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-CNTF3L2LQC"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-CNTF3L2LQC');
</script>  <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?a2d27f70a2f1f5f5edfb5884096627ae";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script> 
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="keywords" content="" />
    <meta name="description" content="" />
    
    <title>
      一个隐藏在Go语言标准库中的目录穿越漏洞 CVE-2022-29804 - 白帽酱の博客
    </title>
    <link rel="manifest" href="/manifest.json" />
    <link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" />
    
<link rel="stylesheet" href="/style/style.css">

  <meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="白帽酱の博客" type="application/atom+xml">
</head>
  <body>
    <canvas id='pagemap'></canvas>
    
    <div id="post-toc" class="animated hiddenToc hide">
      <span class="title">Toc</span>
      <ol class="toc"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%9C%E8%80%85-%E6%A9%99%E5%AD%90%E9%85%B1"><span class="toc-text">作者:橙子酱</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1"><span class="toc-text">代码审计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%B8%B8%E5%AE%89%E5%85%A8%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-text">非常安全的代码?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84%E6%BC%8F%E6%B4%9E"><span class="toc-text">标准库中的漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#filepath-Clean"><span class="toc-text">filepath.Clean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#filepath-Join"><span class="toc-text">filepath.Join</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%8F%E6%8F%92%E6%9B%B2"><span class="toc-text">小插曲</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%BD%B1%E5%93%8D-amp-%E5%88%A9%E7%94%A8%E6%9D%A1%E4%BB%B6"><span class="toc-text">漏洞影响&amp;利用条件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-text">解决方法</span></a>
    </div>
    
    <div id="fixed-menu-wrap">
      <span class="iconfont icon-sousuo search-box menu-reset"></span>
      <span class="icon-toc menu-reset">Toc</span>
      <span class="iconfont icon-arrowup menu-reset"></span>
    </div>
    <div id="fixed-menu">
      <span class="iconfont icon-menu-"></span>
    </div>
    <div id="progress">
      <div class="line"></div>
    </div>
    <div id="search-shade" class="animated hiddenSearch hide">
      <div class="input-wrap">
        <span class="iconfont icon-sousuo search-box"></span>
        <input type="text" placeholder="Search" />
        <span class="iconfont icon-close"></span>
      </div>
      <div class="search-result">
        <div class="meta">
          <span><b id="result-count">0</b> results found</span>
          <img src="/images/logo.jpeg" />
        </div>
        <ul id="result-box"></ul>
      </div>
    </div>
    <div id="menu-mask" class="animated hideMenuMask hide">
      <span class="iconfont icon-close"></span>
      <div class="nav">
        
        <a href="/" class="">
          首页
        </a>
        
        <a href="/archives" class="">
          归档
        </a>
        
        <a href="/categories" class="">
          分类
        </a>
        
        <a href="/tags" class="">
          标签
        </a>
        
        <a href="/friends" class="">
          友链
        </a>
        
        <a href="/about" class="">
          关于
        </a>
        
      </div>
    </div>
    <div id="header">
      <div class="intro">
        <a href="/" class="logo" style="background-image: url('/images/logo.jpeg')"></a>
        <div class="author">白帽酱</div>
      </div>
      <div class="nav">
        <span class="iconfont icon-menu menu-icon"></span>
        <a href="#" class="search-box">
          <span class="iconfont icon-sousuo"></span>
        </a>
      </div>
    </div>
    <div id="side" class="animated bounceInLeft">
      <div class="shrink">
        <a href="/" class="logo" style="background-image: url('/images/logo.jpeg')"></a>
        <span class="iconfont icon-menu toggle-icon"></span>
        <a href="#" class="search-box">
          <span class="iconfont icon-sousuo"></span>
        </a>
      </div>
      <div class="magnify">
        <div class="about">
          <div class="author">白帽酱</div>
          <a href="/" class="logo" style="background-image: url('/images/logo.jpeg')"></a>
        </div>

        <div class="nav">
          
          <a href="/" class="">
            首页
          </a>
          
          <a href="/archives" class="">
            归档
          </a>
          
          <a href="/categories" class="">
            分类
          </a>
          
          <a href="/tags" class="">
            标签
          </a>
          
          <a href="/friends" class="">
            友链
          </a>
          
          <a href="/about" class="">
            关于
          </a>
          
          <a href="#" class="search-box">
            <span class="iconfont icon-sousuo"></span>
          </a>
        </div>
        <div class="bottom">
          <div class="follow">
            
            <a href="https://github.com/burpheart" target="_block">
              <span class="iconfont icon-github"></span>
            </a>
            
            <a href="https://twitter.com/burp_heart" target="_block">
              <span class="iconfont icon-twitter"></span>
            </a>
            
            <a href="https://space.bilibili.com/32890488" target="_block">
              <span class="iconfont icon-bilibili"></span>
            </a>
             
            <a href="/atom.xml" target="_block">
              <span class="iconfont icon-rss"></span>
            </a>
            
          </div>
        </div>
      </div>
    </div>
    <div id="container">
      <div class="main animated bounceInRight delay-0.7s">
        <article class="post-entry">
    <div class="header">
      
      <div class="title">一个隐藏在Go语言标准库中的目录穿越漏洞 CVE-2022-29804</div>
      <div class="meta">
        <span class="item">
          <span class="iconfont icon-time-circle"></span>
          <span>2023/03/25</span>
        </span>

        

         
        <span class="item">
          <span class="iconfont icon-folder"></span>
          <span>
              
                
                  <a href="/categories/漏洞分析">漏洞分析</a>
                
              
          </span>
        </span>
        
        
         
          <span class="item">
            <span class="iconfont icon-tag1"></span>
            <span>
                
                  
                    <a href="/tags/WEB">WEB</a>
                  
                
                  
                    <a href="/tags/CVE">CVE</a>
                  
                
                  
                    <a href="/tags/0DAY">0DAY</a>
                  
                
            </span>
          </span>
         
      </div>
      <div>
      </div>
    </div>
    <html><head></head><body><h6 id="作者-橙子酱">作者:<a href="https://rce.moe/">橙子酱</a><a class="post-anchor" href="#作者-橙子酱"></a></h6><h1 id="前言">前言<a class="post-anchor" href="#前言"></a></h1><p>这是半年前我在 Go 语言中发现的一个目录穿越漏洞（虽然被人抢先发现了）。<br>Go 语言支持非常方便的交叉编译，但是在不同平台下，操作系统对某些功能的实现有所差异。这些差异可能会导致一些安全问题。</p>
<span id="more"></span>
<p>   一天，我看完了番剧后，闲着无聊审计了一下我用来做内网共享的小工具——“Go HTTP File Server”。<br>这是一个跨平台的文件服务器，它可以快速搭建一个简单的HTTP服务器来共享文件。<br>它的默认共享路径为当前路径（./）</p>
<p><a target="_blank" rel="noopener" href="https://cdn.nlark.com/yuque/0/2023/png/25577536/1679627867744-02e0e4fd-715f-4fc5-8f01-5d3ac176fc9d.png#averageHue=%23ececeb&amp;clientId=ubd60b400-7bf4-4&amp;from=paste&amp;height=721&amp;id=u76f76f65&amp;name=%E5%9B%BE%E7%89%87.png&amp;originHeight=901&amp;originWidth=1713&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=96052&amp;status=done&amp;style=none&amp;taskId=uf60ea897-9485-4ad0-8348-a304d45df19&amp;title=&amp;width=1370.4" data-caption="图片.png" data-fancybox="images"><img src="https://cdn.nlark.com/yuque/0/2023/png/25577536/1679627867744-02e0e4fd-715f-4fc5-8f01-5d3ac176fc9d.png#averageHue=%23ececeb&amp;clientId=ubd60b400-7bf4-4&amp;from=paste&amp;height=721&amp;id=u76f76f65&amp;name=%E5%9B%BE%E7%89%87.png&amp;originHeight=901&amp;originWidth=1713&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=96052&amp;status=done&amp;style=none&amp;taskId=uf60ea897-9485-4ad0-8348-a304d45df19&amp;title=&amp;width=1370.4" alt="图片.png"></a></p>
<h1 id="代码审计">代码审计<a class="post-anchor" href="#代码审计"></a></h1><h3 id="非常安全的代码">非常安全的代码?<a class="post-anchor" href="#非常安全的代码"></a></h3><p>这个工具默认是没有鉴权的  所以我们直接看文件浏览的部分</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *HTTPStaticServer)</span> <span class="hljs-title">getRealPath</span><span class="hljs-params">(r *http.Request)</span> <span class="hljs-title">string</span></span> {<br>	path := mux.Vars(r)[<span class="hljs-string">"path"</span>]<br>	<span class="hljs-keyword">if</span> !strings.HasPrefix(path, <span class="hljs-string">"/"</span>) {<br>		path = <span class="hljs-string">"/"</span> + path<br>	}<br>	path = filepath.Clean(path) <span class="hljs-comment">// prevent .. for safe issues</span><br>	relativePath, err := filepath.Rel(s.Prefix, path)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {<br>		relativePath = path<br>	}<br>	realPath := filepath.Join(s.Root, relativePath)<br>	<span class="hljs-keyword">return</span> filepath.ToSlash(realPath)<br>}<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *HTTPStaticServer)</span> <span class="hljs-title">hIndex</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> {<br>    path := mux.Vars(r)[<span class="hljs-string">"path"</span>]<br>    realPath := s.getRealPath(r)<br>    <span class="hljs-keyword">if</span> r.FormValue(<span class="hljs-string">"json"</span>) == <span class="hljs-string">"true"</span> {<br>        s.hJSONList(w, r)<br>        <span class="hljs-keyword">return</span><br>    }<br><br>    <span class="hljs-keyword">if</span> r.FormValue(<span class="hljs-string">"op"</span>) == <span class="hljs-string">"info"</span> {<br>        s.hInfo(w, r)<br>        <span class="hljs-keyword">return</span><br>    }<br><br>    <span class="hljs-keyword">if</span> r.FormValue(<span class="hljs-string">"op"</span>) == <span class="hljs-string">"archive"</span> {<br>        s.hZip(w, r)<br>        <span class="hljs-keyword">return</span><br>    }<br><br>    log.Println(<span class="hljs-string">"GET"</span>, path, realPath)<br>    <span class="hljs-keyword">if</span> r.FormValue(<span class="hljs-string">"raw"</span>) == <span class="hljs-string">"false"</span> || isDir(realPath) {<br>        <span class="hljs-keyword">if</span> r.Method == <span class="hljs-string">"HEAD"</span> {<br>            <span class="hljs-keyword">return</span><br>        }<br>        renderHTML(w, <span class="hljs-string">"assets/index.html"</span>, s)<br>    } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">if</span> filepath.Base(path) == YAMLCONF {<br>            auth := s.readAccessConf(realPath)<br>            <span class="hljs-keyword">if</span> !auth.Delete {<br>                http.Error(w, <span class="hljs-string">"Security warning, not allowed to read"</span>, http.StatusForbidden)<br>                <span class="hljs-keyword">return</span><br>            }<br>        }<br>        <span class="hljs-keyword">if</span> r.FormValue(<span class="hljs-string">"download"</span>) == <span class="hljs-string">"true"</span> {<br>            w.Header().Set(<span class="hljs-string">"Content-Disposition"</span>, <span class="hljs-string">"attachment; filename="</span>+strconv.Quote(filepath.Base(path)))<br>        }<br>        http.ServeFile(w, r, realPath)<br>    }<br>}<br><br></code></pre></td></tr></tbody></table></figure>
<p>乍一看上去，这段代码好像没有什么问题。它使用了 Go 标准库中的 <code>filepath.Clean</code> (去除 ..) 和 <code>filepath.Join</code>(合并路径) 函数，来防止目录穿越。</p>
<h3 id="标准库中的漏洞">标准库中的漏洞<a class="post-anchor" href="#标准库中的漏洞"></a></h3><p> 我刚好还有些空余时间，所以我又开始检查 Go 标准库中的函数实现。  </p>
<h4 id="filepath-Clean">filepath.Clean<a class="post-anchor" href="#filepath-Clean"></a></h4><figure class="highlight go"><table><tbody><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Clean</span><span class="hljs-params">(path <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> {<br>	originalPath := path<br>	volLen := volumeNameLen(path)<br>	path = path[volLen:]<br>	<span class="hljs-keyword">if</span> path == <span class="hljs-string">""</span> {<br>		<span class="hljs-keyword">if</span> volLen &gt; <span class="hljs-number">1</span> &amp;&amp; originalPath[<span class="hljs-number">1</span>] != <span class="hljs-string">':'</span> {<br>			<span class="hljs-comment">// should be UNC</span><br>			<span class="hljs-keyword">return</span> FromSlash(originalPath)<br>		}<br>		<span class="hljs-keyword">return</span> originalPath + <span class="hljs-string">"."</span><br>	}<br>	rooted := os.IsPathSeparator(path[<span class="hljs-number">0</span>])<br><br>	<span class="hljs-comment">// Invariants:</span><br>	<span class="hljs-comment">//	reading from path; r is index of next byte to process.</span><br>	<span class="hljs-comment">//	writing to buf; w is index of next byte to write.</span><br>	<span class="hljs-comment">//	dotdot is index in buf where .. must stop, either because</span><br>	<span class="hljs-comment">//		it is the leading slash or it is a leading ../../.. prefix.</span><br>	n := <span class="hljs-built_in">len</span>(path)<br>	out := lazybuf{path: path, volAndPath: originalPath, volLen: volLen}<br>	r, dotdot := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>	<span class="hljs-keyword">if</span> rooted {<br>		out.<span class="hljs-built_in">append</span>(Separator)<br>		r, dotdot = <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br>	}<br><br>	<span class="hljs-keyword">for</span> r &lt; n {<br>		<span class="hljs-keyword">switch</span> {<br>		<span class="hljs-keyword">case</span> os.IsPathSeparator(path[r]):<br>			<span class="hljs-comment">// empty path element</span><br>			r++<br>		<span class="hljs-keyword">case</span> path[r] == <span class="hljs-string">'.'</span> &amp;&amp; r+<span class="hljs-number">1</span> == n:<br>			<span class="hljs-comment">// . element</span><br>			r++<br>		<span class="hljs-keyword">case</span> path[r] == <span class="hljs-string">'.'</span> &amp;&amp; os.IsPathSeparator(path[r+<span class="hljs-number">1</span>]):<br>			<span class="hljs-comment">// ./ element</span><br>			r++<br><br>			<span class="hljs-keyword">for</span> r &lt; <span class="hljs-built_in">len</span>(path) &amp;&amp; os.IsPathSeparator(path[r]) {<br>				r++<br>			}<br>			<span class="hljs-keyword">if</span> out.w == <span class="hljs-number">0</span> &amp;&amp; volumeNameLen(path[r:]) &gt; <span class="hljs-number">0</span> {<br>				<span class="hljs-comment">// When joining prefix "." and an absolute path on Windows,</span><br>				<span class="hljs-comment">// the prefix should not be removed.</span><br>				out.<span class="hljs-built_in">append</span>(<span class="hljs-string">'.'</span>)<br>			}<br>		<span class="hljs-keyword">case</span> path[r] == <span class="hljs-string">'.'</span> &amp;&amp; path[r+<span class="hljs-number">1</span>] == <span class="hljs-string">'.'</span> &amp;&amp; (r+<span class="hljs-number">2</span> == n || os.IsPathSeparator(path[r+<span class="hljs-number">2</span>])):<br>			<span class="hljs-comment">// .. element: remove to last separator</span><br>			r += <span class="hljs-number">2</span><br>			<span class="hljs-keyword">switch</span> {<br>			<span class="hljs-keyword">case</span> out.w &gt; dotdot:<br>				<span class="hljs-comment">// can backtrack</span><br>				out.w--<br>				<span class="hljs-keyword">for</span> out.w &gt; dotdot &amp;&amp; !os.IsPathSeparator(out.index(out.w)) {<br>					out.w--<br>				}<br>			<span class="hljs-keyword">case</span> !rooted:<br>				<span class="hljs-comment">// cannot backtrack, but not rooted, so append .. element.</span><br>				<span class="hljs-keyword">if</span> out.w &gt; <span class="hljs-number">0</span> {<br>					out.<span class="hljs-built_in">append</span>(Separator)<br>				}<br>				out.<span class="hljs-built_in">append</span>(<span class="hljs-string">'.'</span>)<br>				out.<span class="hljs-built_in">append</span>(<span class="hljs-string">'.'</span>)<br>				dotdot = out.w<br>			}<br>		<span class="hljs-keyword">default</span>:<br>			<span class="hljs-comment">// real path element.</span><br>			<span class="hljs-comment">// add slash if needed</span><br>			<span class="hljs-keyword">if</span> rooted &amp;&amp; out.w != <span class="hljs-number">1</span> || !rooted &amp;&amp; out.w != <span class="hljs-number">0</span> {<br>				out.<span class="hljs-built_in">append</span>(Separator)<br>			}<br>			<span class="hljs-comment">// copy element</span><br>			<span class="hljs-keyword">for</span> ; r &lt; n &amp;&amp; !os.IsPathSeparator(path[r]); r++ {<br>				out.<span class="hljs-built_in">append</span>(path[r])<br>			}<br>		}<br>	}<br><br>	<span class="hljs-comment">// Turn empty string into "."</span><br>	<span class="hljs-keyword">if</span> out.w == <span class="hljs-number">0</span> {<br>		out.<span class="hljs-built_in">append</span>(<span class="hljs-string">'.'</span>)<br>	}<br><br>	<span class="hljs-keyword">return</span> FromSlash(out.<span class="hljs-keyword">string</span>())<br>}<br><br></code></pre></td></tr></tbody></table></figure>
<p>调试了一遍后，我发现 <code>filepath.Clean</code> 对路径处理非常完美。这个函数可以将路径中的冗余部分去除，同时可以处理不同操作系统下的路径分隔符问题.</p>
<h4 id="filepath-Join">filepath.Join<a class="post-anchor" href="#filepath-Join"></a></h4><p>但是 filepath.Join 函数就不太一样了，这个函数在 Plan9、Unix 和 Windows 三个操作系统类型下有着不同的实现。  </p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">join</span><span class="hljs-params">(elem []<span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> {<br>	<span class="hljs-comment">// If there's a bug here, fix the logic in ./path_plan9.go too.</span><br>	<span class="hljs-keyword">for</span> i, e := <span class="hljs-keyword">range</span> elem {<br>		<span class="hljs-keyword">if</span> e != <span class="hljs-string">""</span> {<br>			<span class="hljs-keyword">return</span> Clean(strings.Join(elem[i:], <span class="hljs-keyword">string</span>(Separator)))<br>		}<br>	}<br>	<span class="hljs-keyword">return</span> <span class="hljs-string">""</span><br>}<br><br></code></pre></td></tr></tbody></table></figure>
<p> 在 Unix 系统下，filepath.Join 非常简单，它会在Clean之后直接拼接路径，没有任何问题。  </p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">volumeNameLen</span><span class="hljs-params">(path <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> {<br>	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) &lt; <span class="hljs-number">2</span> {<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>	}<br>	<span class="hljs-comment">// with drive letter</span><br>	c := path[<span class="hljs-number">0</span>]<br>	<span class="hljs-keyword">if</span> path[<span class="hljs-number">1</span>] == <span class="hljs-string">':'</span> &amp;&amp; (<span class="hljs-string">'a'</span> &lt;= c &amp;&amp; c &lt;= <span class="hljs-string">'z'</span> || <span class="hljs-string">'A'</span> &lt;= c &amp;&amp; c &lt;= <span class="hljs-string">'Z'</span>) {<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>	}<br>	<span class="hljs-comment">// is it UNC? https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx</span><br>	<span class="hljs-keyword">if</span> l := <span class="hljs-built_in">len</span>(path); l &gt;= <span class="hljs-number">5</span> &amp;&amp; isSlash(path[<span class="hljs-number">0</span>]) &amp;&amp; isSlash(path[<span class="hljs-number">1</span>]) &amp;&amp;<br>		!isSlash(path[<span class="hljs-number">2</span>]) &amp;&amp; path[<span class="hljs-number">2</span>] != <span class="hljs-string">'.'</span> {<br>		<span class="hljs-comment">// first, leading `\\` and next shouldn't be `\`. its server name.</span><br>		<span class="hljs-keyword">for</span> n := <span class="hljs-number">3</span>; n &lt; l<span class="hljs-number">-1</span>; n++ {<br>			<span class="hljs-comment">// second, next '\' shouldn't be repeated.</span><br>			<span class="hljs-keyword">if</span> isSlash(path[n]) {<br>				n++<br>				<span class="hljs-comment">// third, following something characters. its share name.</span><br>				<span class="hljs-keyword">if</span> !isSlash(path[n]) {<br>					<span class="hljs-keyword">if</span> path[n] == <span class="hljs-string">'.'</span> {<br>						<span class="hljs-keyword">break</span><br>					}<br>					<span class="hljs-keyword">for</span> ; n &lt; l; n++ {<br>						<span class="hljs-keyword">if</span> isSlash(path[n]) {<br>							<span class="hljs-keyword">break</span><br>						}<br>					}<br>					<span class="hljs-keyword">return</span> n<br>				}<br>				<span class="hljs-keyword">break</span><br>			}<br>		}<br>	}<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>}<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">join</span><span class="hljs-params">(elem []<span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> {<br>	<span class="hljs-keyword">for</span> i, e := <span class="hljs-keyword">range</span> elem {<br>		<span class="hljs-keyword">if</span> e != <span class="hljs-string">""</span> {<br>			<span class="hljs-keyword">return</span> joinNonEmpty(elem[i:])<br>		}<br>	}<br>	<span class="hljs-keyword">return</span> <span class="hljs-string">""</span><br>}<br><br><span class="hljs-comment">// joinNonEmpty is like join, but it assumes that the first element is non-empty.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">joinNonEmpty</span><span class="hljs-params">(elem []<span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> {<br>	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(elem[<span class="hljs-number">0</span>]) == <span class="hljs-number">2</span> &amp;&amp; elem[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] == <span class="hljs-string">':'</span> {<br>		<span class="hljs-comment">// First element is drive letter without terminating slash.</span><br>		<span class="hljs-comment">// Keep path relative to current directory on that drive.</span><br>		<span class="hljs-comment">// Skip empty elements.</span><br>		i := <span class="hljs-number">1</span><br>		<span class="hljs-keyword">for</span> ; i &lt; <span class="hljs-built_in">len</span>(elem); i++ {<br>			<span class="hljs-keyword">if</span> elem[i] != <span class="hljs-string">""</span> {<br>				<span class="hljs-keyword">break</span><br>			}<br>		}<br>		<span class="hljs-keyword">return</span> Clean(elem[<span class="hljs-number">0</span>] + strings.Join(elem[i:], <span class="hljs-keyword">string</span>(Separator)))<br>	}<br>	<span class="hljs-comment">// The following logic prevents Join from inadvertently creating a</span><br>	<span class="hljs-comment">// UNC path on Windows. Unless the first element is a UNC path, Join</span><br>	<span class="hljs-comment">// shouldn't create a UNC path. See golang.org/issue/9167.</span><br>	p := Clean(strings.Join(elem, <span class="hljs-keyword">string</span>(Separator)))<br>	<span class="hljs-keyword">if</span> !isUNC(p) {<br>		<span class="hljs-keyword">return</span> p<br>	}<br>	<span class="hljs-comment">// p == UNC only allowed when the first element is a UNC path.</span><br>	head := Clean(elem[<span class="hljs-number">0</span>])<br>	<span class="hljs-keyword">if</span> isUNC(head) {<br>		<span class="hljs-keyword">return</span> p<br>	}<br>	<span class="hljs-comment">// head + tail == UNC, but joining two non-UNC paths should not result</span><br>	<span class="hljs-comment">// in a UNC path. Undo creation of UNC path.</span><br>	tail := Clean(strings.Join(elem[<span class="hljs-number">1</span>:], <span class="hljs-keyword">string</span>(Separator)))<br>	<span class="hljs-keyword">if</span> head[<span class="hljs-built_in">len</span>(head)<span class="hljs-number">-1</span>] == Separator {<br>		<span class="hljs-keyword">return</span> head + tail<br>	}<br>	<span class="hljs-keyword">return</span> head + <span class="hljs-keyword">string</span>(Separator) + tail<br>}<br><br><span class="hljs-comment">// isUNC reports whether path is a UNC path.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isUNC</span><span class="hljs-params">(path <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> {<br>	<span class="hljs-keyword">return</span> volumeNameLen(path) &gt; <span class="hljs-number">2</span><br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sameWord</span><span class="hljs-params">(a, b <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> {<br>	<span class="hljs-keyword">return</span> strings.EqualFold(a, b)<br>}<br></code></pre></td></tr></tbody></table></figure>
<p> 在 Windows 系统下，filepath.Join 函数的实现要复杂得多，因为需要处理路径分隔符和 UNC 路径等特殊情况。<br>到这里就变得有趣了一些 filepath.Join 的输入不完全是用户控制的  Clean函数会把用户输入和固定路径一起处理<br>这个工具刚好出现了一个非常特殊的情况<br>文件服务器本来想要限制访问当前目录下的文件<br><code>filepath.Join("./",'已经处理后的用户输入')</code><br>如果输入的路径是<code>./ abc/1.txt</code><br>Clean处理后会变成 <code>abc/1.txt</code> Clean去除了开头的设定的<code>./</code><br>这个处理在linux系统下没有问题<br>但是在windows 系统下 如果我们构造路径组<code>./ c:/1.txt</code><br>Clean处理后会变成 <code>c:/1.txt</code><br>显然从Clean处理后把当前目录下的路径变为了c盘根目录<br>在这里，filepath.Clean 函数的处理并没有避免目录穿越问题，反而造成了一个安全漏洞。<br>最终在http server 上复现成功</p>
<h1 id="小插曲"><a target="_blank" rel="noopener" href="https://cdn.nlark.com/yuque/0/2023/png/25577536/1679631824560-60e29461-3036-4afd-8aad-db990eae51db.png#averageHue=%23fbfafa&amp;clientId=ubd60b400-7bf4-4&amp;from=paste&amp;height=613&amp;id=u382639de&amp;name=%E5%9B%BE%E7%89%87.png&amp;originHeight=766&amp;originWidth=1423&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=89966&amp;status=done&amp;style=none&amp;taskId=u0924afc1-6476-432a-9663-fd9ef005668&amp;title=&amp;width=1138.4" data-caption="图片.png" data-fancybox="images"><img src="https://cdn.nlark.com/yuque/0/2023/png/25577536/1679631824560-60e29461-3036-4afd-8aad-db990eae51db.png#averageHue=%23fbfafa&amp;clientId=ubd60b400-7bf4-4&amp;from=paste&amp;height=613&amp;id=u382639de&amp;name=%E5%9B%BE%E7%89%87.png&amp;originHeight=766&amp;originWidth=1423&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=89966&amp;status=done&amp;style=none&amp;taskId=u0924afc1-6476-432a-9663-fd9ef005668&amp;title=&amp;width=1138.4" alt="图片.png"></a><a target="_blank" rel="noopener" href="https://cdn.nlark.com/yuque/0/2023/png/25577536/1679631882231-add563fd-8eb9-402c-9d15-965d07d6af26.png#averageHue=%23f8f7f7&amp;clientId=ubd60b400-7bf4-4&amp;from=paste&amp;height=706&amp;id=u487e72c3&amp;name=%E5%9B%BE%E7%89%87.png&amp;originHeight=882&amp;originWidth=1634&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=153240&amp;status=done&amp;style=none&amp;taskId=ude5f45e8-547d-4c17-b0eb-12398a0c85d&amp;title=&amp;width=1307.2" data-caption="图片.png" data-fancybox="images"><img src="https://cdn.nlark.com/yuque/0/2023/png/25577536/1679631882231-add563fd-8eb9-402c-9d15-965d07d6af26.png#averageHue=%23f8f7f7&amp;clientId=ubd60b400-7bf4-4&amp;from=paste&amp;height=706&amp;id=u487e72c3&amp;name=%E5%9B%BE%E7%89%87.png&amp;originHeight=882&amp;originWidth=1634&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=153240&amp;status=done&amp;style=none&amp;taskId=ude5f45e8-547d-4c17-b0eb-12398a0c85d&amp;title=&amp;width=1307.2" alt="图片.png"></a>小插曲<a class="post-anchor" href="#小插曲"></a></h1><p>提交给go 官方之后才发现这洞3个月前就被修复了. 我电脑上的go版本一直没更新 23333<br><a target="_blank" rel="noopener" href="https://cdn.nlark.com/yuque/0/2023/png/25577536/1679632243752-ec9dd6f3-0c68-49bb-bb2f-dc107c5acf82.png#averageHue=%23f9f9f9&amp;clientId=ubd60b400-7bf4-4&amp;from=paste&amp;height=454&amp;id=ua4ccd112&amp;name=%E5%9B%BE%E7%89%87.png&amp;originHeight=568&amp;originWidth=1114&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=79651&amp;status=done&amp;style=none&amp;taskId=ufc343c09-2a17-4deb-b477-78c815045b1&amp;title=&amp;width=891.2" data-caption="图片.png" data-fancybox="images"><img src="https://cdn.nlark.com/yuque/0/2023/png/25577536/1679632243752-ec9dd6f3-0c68-49bb-bb2f-dc107c5acf82.png#averageHue=%23f9f9f9&amp;clientId=ubd60b400-7bf4-4&amp;from=paste&amp;height=454&amp;id=ua4ccd112&amp;name=%E5%9B%BE%E7%89%87.png&amp;originHeight=568&amp;originWidth=1114&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=79651&amp;status=done&amp;style=none&amp;taskId=ufc343c09-2a17-4deb-b477-78c815045b1&amp;title=&amp;width=891.2" alt="图片.png"></a>漏洞issue<br><a target="_blank" rel="noopener" href="https://github.com/golang/go/issues/52476">https://github.com/golang/go/issues/52476</a></p>
<h1 id="漏洞影响-amp-利用条件">漏洞影响&amp;利用条件<a class="post-anchor" href="#漏洞影响-amp-利用条件"></a></h1><ol>
<li>使用 <code>filepath.Clean/filepath.Join</code> 处理路径</li>
<li>左侧被拼接路径为<code>./</code></li>
<li>右侧路径可完全控制</li>
<li>Go编译Windows二进制文件使用  Go 1.18 &lt;1.18.3  Go 1.17 &lt;1.17.11 (不在维护的版本应该不会修复)</li>
<li>目标二进制部署在windows 操作系统</li>
</ol>
<p>标准库的漏洞会影响编译分发出的二进制文件</p>
<h1 id="解决方法">解决方法<a class="post-anchor" href="#解决方法"></a></h1><p>更新go到最新版本 重新编译发布二进制文件</p>
</body></html>

  
  <div class="post-guide">
    <div class="item left">
        
          <a href="/2023/04/11/untitled-1681175333602/">联网大语言模型的prompt注入问题：一个隐藏的危机</a>
        
    </div>
    <div class="item right">
        
          <a href="/2023/03/23/koko-moni/">koko-moni 一个网络空间搜索引擎监控平台</a>
        
    </div>
  </div>

  

  <div class="post-copyright">
    <div class="auth">
      本文作者：<a href="https://rce.moe">白帽酱</a>
    </div>
    <div class="link">
      永久链接：<a href="https://rce.moe/2023/03/25/CVE-2022-29804/">https://rce.moe/2023/03/25/CVE-2022-29804/</a>
    </div>
    <div class="declare">
      版权声明：本文首发于<a href="https://rce.moe">白帽酱</a>的博客，转载请注明出处！
    </div>
  </div>

  <div id="comment"></div>

  
  
</article>
<div id="gitalk-container"></div>
<link rel="stylesheet" href="https://unpkg.com/gitalk@latest/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script>
<script src="https://priesttomb.github.io/js/md5.min.js"></script>
<script type="text/javascript">
    new Gitalk({
        clientID: '1488ae49eda310270a91',
        clientSecret: '83e505f36d0351b0ef1a225d089546cb40ecd31a',
        repo: 'hexoblog',
        owner: 'burpheart',
        admin: 'burpheart',
        id: md5(location.pathname),
        distractionFreeMode: true,
        proxy: 'https://servelesscors.rce.moe/api/cors?url=https://github.com/login/oauth/access_token'
    }).render('gitalk-container')
</script>
        <footer>
          <div class="copyright">
            ©2024
            <a href="https://rce.moe">白帽酱</a> Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> |
            <a target="_blank" rel="noopener" href="https://github.com/shixiaohu2206/hexo-theme-huhu">hexo-theme-huhu</a>
          </div>
          
        </footer>
      </div>
    </div>
  </body>
  
</html>
<script type="text/javascript">
                  window.HUHU_CONFIG = JSON.parse("{\"share\":[\"weibo\",\"weixin\",\"qqkongjian\",\"QQ\",\"douban\",\"facebook\",\"twitter\",\"google\"],\"service_worker\":{\"open\":false}}")
                </script> <script type="text/javascript">window.addEventListener('load', function() {
    
    window.loadJs = function(d, m, a) {
      var c = document.getElementsByTagName('head')[0] || document.head || document.documentElement
      var b = document.createElement('script')
      b.defer = true
      b.setAttribute('type', 'text/javascript')
      b.setAttribute('charset', 'UTF-8')
      b.setAttribute('async', 'true')
      b.setAttribute('src', d)
      m && b.setAttribute('data-main', '/scripts/app-built')
      if (typeof a === 'function') {
        if (window.attachEvent) {
          b.onreadystatechange = function() {
            var e = b.readyState
            if (e === 'loaded' || e === 'complete') {
              b.onreadystatechange = null
              a()
            }
          }
        } else {
          b.onload = a
        }
      }
      c.appendChild(b)
    }
    window.loadJs && window.loadJs('https://cdn.bootcss.com/require.js/2.3.6/require.min.js', true, function() {require.config({"paths":{"util":"util","share":"share","search":"search","pagemap":"pagemap.min","registerSW":"registerSW","valine":"cdn/Valine.min","av":["https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min"],"pjax":["https://cdn.bootcss.com/jquery.pjax/2.0.1/jquery.pjax.min"],"jquery":["https://cdn.bootcss.com/jquery/3.4.1/jquery.min"],"confirm":["https://cdn.bootcss.com/jquery-confirm/3.3.4/jquery-confirm.min"],"fancybox":["https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min"],"chart":["https://cdn.bootcss.com/Chart.js/2.8.0-rc.1/Chart.bundle.min"]},"map":{"*":{"css":"https://cdn.bootcss.com/require-css/0.1.10/css.min.js"}},"shim":{"fancybox":{"deps":["css!https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.css"]},"confirm":{"deps":["css!https://cdn.bootcss.com/jquery-confirm/3.3.4/jquery-confirm.min.css"]},"chart":{"deps":["css!https://cdn.bootcss.com/Chart.js/2.8.0-rc.1/Chart.min.css"]}},"waitSeconds":3})})
  })</script> <script type="text/javascript">
                  ;(function() {
                    var bp = document.createElement('script')
                    var curProtocol = window.location.protocol.split(':')[0]
                    if (curProtocol === 'https') {
                      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'
                    } else {
                      bp.src = 'http://push.zhanzhang.baidu.com/push.js'
                    }
                    var s = document.getElementsByTagName('script')[0]
                    s.parentNode.insertBefore(bp, s)
                  })()
                </script> 
